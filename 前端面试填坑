
前端基础

1、前端页面由哪三层构成，分别是什么，作用是什么？
Html (结构) : 超文本标记语言, 由 HTML 或 xhtml之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：“这是一个文本段。”
Css (表现) : 层叠样式表 , 由css负责创建。css对“如何显示有关内容”的问题做出了回答。
Js (行为) : 客户端脚本语言 , 内容应该如何对事件做出反应

2、W3C标准  
中文名：万维网联盟
万维网联盟标准不是某一个标准，而是一些列标准的集合。网页主要有三部分组成：结构（Structure）、表现（Presentation）、行为（Behavior）。
对应的标准也有三方面：结构化标准主要包括XHTML和XML，表现标准语言主要包括CSS、行为标准主要包括（如W3C DOM）、ECMAScript等。这些标准大部分是W3C起草发布，也有一是其他标准组织制定的标准，比如ECMAScript（European Computer Manufacturers Association）的ECMAScript的标准。

3、标准规范：
（1）需要声明（DOCTYPE）
DOCTYPE（document type）文档类型的简写，用来说明你用的XHTML或者HTML是什么版本。其中DTD叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的DTD来解释你页面的标识，并展现出来。要建立符合标准的网页，DOCTYPE声明是必不可少的关键组成部分；除非你的XHTML确定了一个正确的DOCTYPE，否则你的标识和css都不会生效。 有过渡的（Transitional）、严格的（strict）、框架的（frameset）
（2）需要定义语言编码
（3）JavaScript定义
Js必须要用<script language="javascript" type="text/javascript">来开头定义，以保证在不支持js的浏览器上直接显示出来。
（4）CSS定义
CSS必须要用<style type=“text/css”>开头来定义，为保证各浏览器的兼容性，在写CSS时请都写上数量单位。
（5）使用注释
（6）所有标签的元素和属性名字都必须使用小写
与HTML不一样，XHTML对大小写是敏感的，<title>和<TITLE>是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。
（7）所有属性值必须用引号括起来（"" ''）双引号或单引号
（8）把所有特殊符号用编码表示
空格为&nbsp; 、小于号（<）&lt、大于号（>）&gt、和号（&）&amp等。
（9）所有属性必须有属性值
XHTML规定所有属性都必须有个值，没有值就是重复本身。
（10）所有的标记都必须有相应的结束标记
双标记：<div></div> 单标记：<img />
（11）所有的标记都必须合理嵌套 
（12）图片添加有意义的alt属性 
图片加载失败时可以用alt属性表明图片内容。同理添加文字链接的title属性，帮助显示不完整的内容显示完整。
（13）在form表单中增加label，以增加用户友好度

结论：
（1）标签规范可以提高搜索引擎对页面的抓取效率，对SEO（搜索引擎优化）很有帮助。
（2）尽量使用外链css样式表和js脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。
（3）样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版。
（4）什么是DOCTYPE
DOCTYPE是document type(文档类型)的简写，用来说明你用的XHTML或者HTML是什么版本。其中的DTD(例如xhtml1-transitional.dtd)叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的DTD来解释你页面的标识，并展现出来。要建立符合标准的网页，DOCTYPE声明是必不可少的关键组成部分；除非你的XHTML确定了一个正确的DOCTYPE，否则你的标识和CSS都不会生效。
（5）名字空间 namespace
<html xmlns="http://www.w3.org/1999/xhtml" lang="gb2312">
通常我们HTML4.0的代码只是<html>，这里的"xmlns"是什么呢？
这个“xmlns”是XHTML namespace的缩写，叫做“名字空间”声明。XHTML是HTML向XML过渡的标识语言，它需要符合XML文档规则，因此也需要定义名字空间。又因为XHTML1.0不能自定义标识，所以它的名字空间都相同，就是"http://www.w3.org/1999/xhtml"。目前阶段我们只要照抄代码就可以了。
（6）定义语言编码
<meta http-equiv=“Content-Type” content=“text/html; charset=gb2312” />
为了被浏览器正确解释和通过W3C代码校验，所有的XHTML文档都必须声明它们所使用的编码语言，我们一般使用gb2312(简体中文)，制作多国语言页面也有可能用Unicode、ISO-8859-1等，根据你的需要定义。
注：如果忘记了定义语言编码,可能就会出现,你在DW(dreamweaver)做完一个页面，第二次打开时所有的中文变成了乱码。
（7）Javascript定义
Js必须要用<script language="javascript" type="text/javascript">来开头定义，而不是原来的<script language=javascript>或干脆直接<script>，并且需要加个注释符<!--   -->，以保证不在不支持js的浏览器上直接显示出代码来。
（8）不要在注释内容中使用“--”
“--”只能发生在XHTML注释的开头和结束，也就是说，在内容中它们不再有效。
例如下面的代码是无效的：<!--这里是注释-----------这里是注释-->
正确的应用等号或者空格替换内部的虚线。<!--这里是注释============这里是注释-->
（9）所有标签的元素和属性的名字都必须使用小写
与HTML不一样，XHTML对大小写是敏感的，<title>和<TITLE>是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。
（10）所有的属性必须用引号""括起来
在HTML中，你可以不需要给属性值加引号，但是在XHTML中，它们必须被加引号。
例如：<height=80>必须修改为：<height="80">。
特殊情况，你需要在属性值里使用双引号，你可以用"，单引号可以使用&apos;，例如：<alt="say&apos;hello&apos;">
（11）把所有<和&特殊符号用编码表示
任何小于号（<），不是标签的一部分，都必须被编码为 &lt;
任何大于号（>），不是标签的一部分，都必须被编码为 &gt;
任何与号（&），不是实体的一部分的，都必须被编码为 &amp; 
（12）给所有属性赋一个值
XHTML规定所有属性都必须有一个值，没有值的就重复本身
（13）所有的标记都必须要有一个相应的结束标记
以前在HTML中，你可以打开许多标签，例如<p>和<li>而不一定写对应的</p>和</li>来关闭它们。但在XHTML中这是不合法的。XHTML要求有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个"/"来关闭它。
（14）所有的标记都必须合理嵌套 
同样因为XHTML要求有严谨的结构，因此所有的嵌套都必须按顺序
（15）图片添加有意义的alt属性
（16）在form表单中增加lable，以增加用户友好度 

4、Web前端面试题：对WEB标准以及W3C的理解与认识？
Web标准简单来说可以分为结构、表现和行为，其中结构主要是由html标签组成，或者通俗点来说，在body中我们写入的标签都是为了页面的结构，表现指css样式表，通过css可使页面的结构标签更具美感，行为是指页面和用户具有一定的交互，同时页面结构或者行为发生变化，主要是js组成。
Web标准一般是将该三部分独立分开，使其更具有模块化，但是一般行为发生变化时，一般伴随着结构或表现的变化。
其中，W3C标准对web标准提出了规范化的要求，也即使代码规范，包括：对结构的要求（标签规范可以提高搜索引擎的抓取效率，对SEO很有帮助），标签的字母要小写，标签要闭合，标签不允许随意嵌套。对css和js，尽量使用外链css样式表和js脚本，使结构，表现和行为分为3块，提高页面渲染速度，提高用户体验，尽量少用行间样式表，使结构与表现分离，标签的id和class等属性做到见闻知意。

HTML

1、Doctype的作用？标准模式与兼容模式各有什么区别？严格模式与混杂模式如何区分？它们有何意义?
   （1）<!Doctype>声明位于HTML文档的第一行，处于<html>标签之前。告知浏览器用什么文档来解析这个文档。Doctype不存在或格式不正确会导致文档以兼容模式呈现。
（2）标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为防止站点无法工作。
  （3）严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。
     1）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
     2）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。

2、HTML和XHTML二者有什么区别
HTML和XHTML之间的差别，粗略可以分为两大类比较：一个是功能上的区别，一个是书写习惯上的区别。功能上的区别主要是XHTML可兼容各大浏览器、手机及ipad，并且浏览器能快速正确的编译网页。书写上的区别主要是因为它的语法比较严谨，例如在XHTML中所有标签都必须小写，不能大小写穿插其中，标签号必须成对，所有属性都必须使用双引号。
最主要的区别是：XHTML元素必须被正确的嵌套，XHML元素必须被关闭，标签名必须被小写，XHTML文档必须拥有根元素。

3、新的HTML5文档类型和字符集是？
HTML5文档类型 <!doctype html>
HTML5使用UTF-8字符集 <meta charset="UTF-8">

4、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？
新特性，新增元素：
1）内容元素：article、footer、header、nav、section
2）表单控件：calendar、date、time、email、url、search
3）控件元素：webworker，websockt，Geolocation
移除元素：
1）显现层元素：basefont，big，center，font，s，strike，tt，u
2）性能较差元素：frame，frameset，noframes

4.1、处理兼容问题有两种方式：
1）IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签。
2）使用是html5shim框架
另外，DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构，功能元素来加以区分。

5、HTML5中如何嵌入音频？
HTML5支持MP3、Wav和Ogg格式的音频，下面是在网页中嵌入音频的简单实例：
<audio controls>
<source src="jamshed.mp3" type="audio/mpeg">

6、HTML5如何嵌入视频？
和音频类似，HTML5支持MP4、WebM和Ogg格式的视频，下面是简单实例：
<embed>标签定义嵌入的内容，比如插件。
   <embed type="video/quicktime" src="Fishing.mov">
<source>对于定义多个数据源很有用。
<video width="450" height="340" controls>
   <source src="jamshed.mp4" type="video/mp4">
   <source src="jamshed.mp4" type="video/ogg">
</video>

7、HTML5 Canvas元素有什么用？
Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在HTML上进行图形操作，
<canvas id="canvas1" width="300" height="100"></canvas>

8、HTML5存储类型有什么区别？
1）HTML5能够本地存储数据，在之前都是使用cookie使用的，HTML5提供了下面两种本地存储方案：
2） localStorage用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。
3） sessionStorage 同一个会话的页面才能访问并且当会话结束后数据也会随之销毁，因此sessionStorage不是一种持久化的本地

9、HTML5的文件离线储存怎么使用，工作原理是什么？
在线情况下，浏览器发现HTML头部有manifest属性，它会请求manifest文件，如果是第一次访问，那么浏览器就会根据manifest文件的内容下载相应的资源，并进行离线存储。如果已经访问过并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面。然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不会做任何操作，如果文件改变了，那么就会重新下载文件中的资源，并且进行离线存储。例如，在页面头部加入manifest属性在cache.manifest文件中编写离线存储的资源。

10、简述一下src与href的区别
href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。
src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。

11、label的作用是什么? 是怎么用的?
label标签用来定义表单控件间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label 中有两个属性是非常有用的, FOR和ACCESSKEY。FOR属性功能：表示label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点 

12、BOM 
BOM 是 Browser Object Model的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个 全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即 BOM。BOM 的核心对象就是 window，window 对象也是 BOM 的顶级对象，其中包含了浏览器的 6 个核心模块： 
（1）document 
即文档对象，渲染引擎在解析 HTML 代码时，会为每一个元素生成对应的DOM 对象，由于元素之间有层级关系，因此整个 HTML 代码解析完以后，会生成一个由不同节点组成的树形结构，俗称 DOM 树，document 
用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。 
（2）frames - HTML 子框架，
即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。 
（3）history 
以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。 
（4）location 
提供了当前窗口中加载的文档相关信息以及一些导航功能。 
（5）navigator 
 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。 
（6）screen 
 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。 

13、DOM 系统
DOM 是 Document Object Model 的缩写，即文档对象模型，是所有浏览器公共遵守的标准，DOM 将 HTML 和 XML 文档映射成一个由不同节点组成的树型结构，俗称 DOM 树。其核心对象是 document，用于描述 DOM 树的状态和属性，并提供对应的 DOM 操作 API。随着历史的发展，DOM 被划分为 1 级、2 级、3 级，共 3 个级别： 
1 级 DOM - 由 DOM 核心与 DOM  HTML 两个模块组成。DOM 核心能映射以 XML 为基础的文档结构，允许获取 和操作文档的任意部分。DOM HTML 通过添加 HTML 专用的对象与函数对 DOM 核心进行了扩展。 
2 级 DOM - 鉴于 1 级 DOM 仅以映射文档结构为目标，DOM 2 级面向更为宽广。通过对原有 DOM 的扩展，2 级 DOM 通过对象接口增加了对鼠标和用户界面事件（DHTML 长期支持鼠标与用户界面事件）、范围、遍 
历（重复执行 DOM 文档）和层叠样式表（CSS）的支持。同时也对 DOM 1 的核心进行了扩展，从而可支持 XML 命名空间。 
3 级 DOM - 通过引入统一方式载入和保存文档和文档验证方法对 DOM 进行进一步扩展，DOM3 包含一个名为“DOM 载入与保存”的新模块，DOM 核心扩展后可支持XML1.0 的所有内容，包括 XML Infoset、 XPath、和 XML Base。 浏览器对不同级别 DOM 的支持情况如下所示： 
DOM2.0 模型将事件处理流程分为三个阶段，即 事件捕获阶段 、 事件处理阶段 、 事件冒泡阶段： 
事件捕获 ：当用户触发点击事件后，顶层对象 document 就会发出一个事件流，从最外层的 DOM 节点向目标元素节点传递，最终到达目标元素。 
事件处理 ：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。 
事件冒泡 ：事件流从目标元素开始，向最外层 DOM 节点传递，途中如果有节点绑定了事处理函数，这些函数就会被执行。
利用事件冒泡原理可以实现 事件委托 ，所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素 
再通过 event.target获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。
 
14、HTML 解析过程 **** 
浏览器加载 html 文件以后，渲染引擎会从上往下，一步步来解析 HTML 标签，大致过程如下： 
（1）用户输入网址，浏览器向服务器发出请求，服务器返回 html 文件； 
（2）渲染引擎开始解析 html 标签，并将标签转化为 DOM 节点，生成 DOM 树； 
如果 head 标签中引用了外部 css 文件，则发出 css 文件请求，服务器返回该文件，该过程会阻塞后面的解析；如果引用了外部 js 文件，则发出 js 文件请求，服务器返回后立即执行该脚本，这个过程也会阻塞 html 的解析； 
（3）引擎开始解析 body 里面的内容，如果标签里引用了 css 样式，就需要解析刚才下载好的 css 文件，然后用 css 来设置标签的样式属性，并生成渲染树；如果 body 中的 img 标签引用了图片资源，则立即向服务器发出请求，此时引擎不会等待图片下载完毕，而是继续解析后面的标签； 
（4）服务器返回图片文件，由于图片需要占用一定的空间，会影响到后面元素的排版，因此引擎需要重新渲染这部分内容；如果此时 js 脚本中运行了 style.display="none"，布局被改变，引擎也需要重新渲染这部分代码； 
（5）直到 html 结束标签为止，页面解析完毕。
 
15、重绘 和 回流 
当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。比如上面的 img 文件加载完成后就会引起回流，每个页面至少需要一次回流，就是在页面第一次加载的时候。 
当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。 
从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。
 
16、本地存储 
本地存储最原始的方式就是 cookie,cookie 是存放在本地浏览器的一段文本， 数据以键值对的形式保存，可以设置过期时间。 但是 cookie 不适合大量数据的存储，因为每请求一次页面，cookie 都会发送给服务器，这使得 cookie 速度很慢而且效率也不高。因此 cookie 的大小被限制为 4k 左右(不同浏览器可 
能不同,分 HOST)，如下所示： 
Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名(name)、值(value) 和 等号。 
Opera 允许 cookie 多达 4096 个字节，包括：名(name)、值(value) 和 等号。 
Internet Explorer 允许 cookie 多达 4095 个字节，包括：名(name)、值(value) 和 等号。 
在所有浏览器中，任何 cookie 大小超过限制都被忽略，且永远不会被设置。html5 提供了两种在客户端存储数据的新方法：localStorage 和 sessionStorage, 它们都是以 key/value 的形式来存储数据，前者是永久存储，后者的存储期限仅限于浏览器会话 (session)，即当浏览器窗口关闭后，sessionStorage 中的数据被清除。 
localStorage 的存储空间大约 5M 左右，这个相当于一个 5M 大小的前端数据库，相比于 cookie，可以节约带宽，但 localStorage 在浏览器隐私模式下是不可读取的，当存储数据超过了localStorage 的存储空间后会抛出异常。

17、Web 语义化 和 SEO 
Web 语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。 
SEO 是指在了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。搜索引擎通过爬虫技术获取的页面就是由一堆 html 标签组成的代码，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器做不到。但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中的重要内容，并予以较高的权值。比如 h1~h6 这几个标签在 SEO 中的权值非常高，用它们作页面的标题就是一个简单的 SEO 优化。

18、Canvas绘图，如：Canvas-图形、Canvas-路径、Canvas-文本、Canvas-渐变、Canvas-图像、SVG与Canvas两者间的区别？
SVG是一种使用XML描述2D图形的语言。Canvas通过js来绘制2D图形。SVG基于XML,这意味着SVG DOM中每个元素都是可用的。
在SVG中，每个被绘制的图形均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形。Canvas是逐像素进行渲染的。在Canvas中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需重新绘制，包括任何已被图形覆盖的对象。
19、简述jpg，gif，png-8，png-24的区别，及其各自的使用场景，gif、jpg、png格式的图片在网站制作中的区别
Gif格式特点:
（1）透明性,Gif是一种布尔透明类型，既它可以是全透明，也可以是全不透明，但是它并没有半透明（alpha透明）。
（2）动画,Gif这种格式支持动画。
（3）无损耗性,Gif是一种无损耗的图像格式，这也意味着你可以对gif图片做任何操作也不会使得图像质量产生损耗。
（4）水平扫描,Gif是使用了一种叫作LZW的算法进行压缩的，当压缩gif的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的gif图片比竖向的gif图片更加小。例如50010的图片比10500的图片更加小.
（5）间隔渐进显示,Gif支持可选择性的间隔渐进显示
　　由以上特点看出只有256种颜色的gif图片不适合照片，但它适合对颜色要求不高的图形（比如说图标，图表等），它并不是最优的选择，我们会在后面中看到png是最优的选择。
Jpeg（jpg）格式特点:
（1）透明性,它并不支持透明。
（2）动画,它也不支持动画。
（3）损耗性,除了一些比如说旋转（仅仅是90、180、270度旋转），裁切，从标准类型到先进类型，编辑图片的原数据之外，所有其它操作对jpeg图像的处理都会使得它的质量损失。所以我们在编辑过程一般用png作为过渡格式。
（4）隔行渐进显示,它支持隔行渐进显示（但是ie浏览器并不支持这个属性，但是ie会在整个图像信息完全到达的时候显示）。
　　由上可以看出Jpeg是最适web上面的摄影图片和数字照相机中。
Png格式特点:
（1）类型,Png这种图片格式包括了许多子类，但是在实践中大致可以分为256色的png和全色的png，你完成可以用256色的png代替gif，用全色的png代替jpeg
（2）透明性,Png是完全支持alpha透明的（透明，半透明，不透明）
（3）动画,它不支持动画
（4）PNG图片格式现在包含三种类型：
　　1）PNG8256色PNG的别名
　　2）PNG24全色PNG的别名
　　3）PNG32全色PNG的别名
（5）每个像素上不仅存储了24位真色彩信息还存储了8位的alpha通道信息，就如同GIF能存储透明和不透明信息一样。当我们把图片放到不太搭配的背景上的时候，透明PNG图片的边缘会显示得更加平滑。
对png8的误解
Png8的在ie中的怪异表现：
　（1）半透明的png8在ie6以下的浏览器显示为全透明。
　（2）Alpha透明的全色PNG（png32）在ie6中会出现背景颜色（通常是灰色）。
由上面可以总结：
（a）全透明的png8可以在任一浏览器正常显示（就像gif一样）。半透明的png8在除了ie6及其以下的浏览器下错误的显示成全透明，其它浏览器都能正常显示半透明。这个bug并不需要特殊对待，因为在不支持半透明的浏览器下只是显示为全透明，对用户体验影响不大，它反而是透明gif的加强版。
（b）第二个bug没有什么好的方法解决，只能通过影响性能的方法AlphaImageLoader与需要加特殊标签。
　
19、简述一下你对HTML语义化的理解？
用正确的标签做正确的事情。HTML语义化让页面结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的；搜索引擎的爬虫也依赖于html标记俩确定上下文和各个关键字的权重，利于SEO；使阅读源代码的人对网站更容易将网站分块，便于阅读维护和理解

CSS
1、CSS 选择器 
CSS 选择器即通过某种规则来匹配相应的标签，并为其设置 CSS 样式，常用的有：
1）id 选择器（#myid）
2）类选择器（.myclassname）
3）标签选择器（div，h1，p）
4）相邻选择器（h1 + p）
5）子选择器（ul > li）
6）后代选择器（li a）
7）通配符选择器（* ）
8）属性选择器（ a[rel = "external"]）
9）伪类选择器（a: hover, li: nth - child）
2、CSS Reset 
HTML 标签在不设置任何样式的情况下，也会有一个默认的 CSS 样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是 CSS Reset ，即 CSS 样式重置。

3、为什么要初始化 CSS 样式
因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。然，初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法是：*{padding:0;margin:0} (不建议)

4、盒子布局 
盒子模型是 CSS 布局的基石。常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding 和 content等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒 
子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing 属性的设置会影响盒子 width 和 height 的计算。 

5、浮动布局 
设置元素的 float 属性值为 left 或 right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear:both，更高级一点的就给父容器设置 before/after 来模拟一个空元素，还可以直接设 置 overflow 属性为 auto/hidden 来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block)和 table 也可以实现同样的效果。
 
6、定位布局 
设置元素的 position 属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。
releave 是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他 元素占用；	absolute 是绝对定位，它以离自己最近的定位父容器作为参照进行偏移；为了对某个元 素进行定位，常用的方式就是设置父容器的 poistion:relative，因为相对定位元素在不设置top 和 left 值时，不会对元素位置产生影响；
fixed 即固定定位，它则以浏览器窗口为参照物，PC 网页底部悬停的 banner 一般都可以通过 fixed 定位来实现，但 fixed 属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。
 
7、弹性布局 
弹性布局即 Flex 布局，定义了 flex 的容器一个可伸缩容器，首先容器本身会 根据容器中的元素动态设置自身大小；然后当 Flex 容器被应用一个大小时（width 和 height），将会自动调整容器中的元素适应新大小。Flex 容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向（横向和纵 
向）和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。
弹性布局的主要思想是让容器有能力改变项目的宽度盒高度，以填满可用空间(主要是为了容纳所有类型的显示设备和屏幕尺寸)的能力。也就是说：Flex布局使得子项目能够“弹性”的改变其高度，自由填充容器容器剩余空间，以适应容器变大，或者压缩子项目自身，以适应容器变小；同时还可以方便的调节子项目方向和顺序。Flex常用于高度需要自适应，或子项目大小成比例，或水平垂直对齐等场景。
8、各种布局
静态布局：给页面元素设置固定的宽度和高度，单位用px，当窗口缩小，会出现滚动条，拉动滚动条显示被遮挡内容。针对不同分辨率的手机端，分别写不同的样式文件。
　　自适应布局：创建多个静态布局，每个静态布局对应一个屏幕分辨率范围，使用@media媒体查询技术。
　　流式布局：元素的宽高用百分比做单位，元素宽高按屏幕分辨率调整，布局不发生变化。屏幕尺度跨度过大的情况下，页面不能正常显示。
　　响应式布局：采用自适应布局和流式布局的综合方式，为不同屏幕分辨率范围创建流式布局。
弹性布局：要点在于使用em和rem单位来定义元素宽度，与流式布局有极大的相似性，但也有不同之处，主要区别在于弹性布局的尺寸主要根据字体大小而变化。

9、CSS3 动画 
CSS3 中规范引入了两种动画，分别是 transition 和 animation.
transition 可以让元素的 CSS 属性值的变化在一段时间内平滑的过渡，形成动画效果，为了使元素的变换更加丰富多彩，CSS3 还引入transfrom 属性，它可以通过对元素进行 平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew)等操作，来实现 2D 和 3D 变换效果。transiton 还有一个结束事件transitionEnd，该事件是在 CSS 完成过渡后触发，如果过渡在完成之前被移除，则不会触发 transitionEnd 。 
animation 需要设置一个@keyframes，来定义元素以哪种形式进行变换，然后再通过动画函数让这种变换平滑的进行，从而达到动画效果，动画可以被设置为永久循环演示。设置 animation-play-state:paused 
可以暂停动画，设置 animation-fill-mode:forwards可以让动画完成后定格在最后一帧。另外，还可以通过 JS 监听 animation 的开始、结束和重复播放时的状态，分别对应三个事件，即animationStart、animationEnd、animationIteration 。注意，当播放次数设置为 1 时，不会触发animationIteration 。 
和 transition 相比，animation 设置动画效果更灵活更丰富，还有一个区别是：transition只能通过主动改变元素的 css 值才能触发动画效果，而 animation 一旦被应用，就开始执行动画。另外，HTML5 还新增了一个动画 API，即 requestAnimationFrame，它通过 JS 来调用，并按照屏幕的绘制频率来改变 
元素的 CSS 属性，从而达到动画效果。 

10、BFC 
BFC 是格式化上下文，与外界元素互不影响，是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素。比如：内部滚动就是一个 BFC，当一个父容器的 overflow-y 设置为 auto 时，并且子容器的长度大于父容器时，就会出现内部滚动，无论内部的元素怎么滚动，都不会影响父容器以外的布局，这个父容器的渲染区域就叫 BFC。满 
足下列条件之一就可触发 BFC： 
（1）根元素，即 HTML 元素 
（2）float 的值不为 none 
（3）overflow 的值不为 visible 
（4）display 的值为 inline-block、table-cell、table-caption 
（5）position 的值为 absolute 或 fixed 

11、Sprite，Iconfont，@font-face 
对于大型站点，为了减少 http 请求的次数，一般会将常用的小图标排到一个大 图中，页面加载时只需请求一次网络，然后在 css 中通过设置 background-position 来控制显示所需要的小图标，这就是 Sprite 图。 
Iconfont，即字体图标，就是将常用的图标转化为字体资源存在文件中，通过在CSS中引用该字体件，然后可以直接用控制字体的 css 属性来设置图标的样式字体图标的好处是节省网络请求、其大小不受屏幕分辨率的影响，并且可以任意修改图标的颜色。
@font-face 是 CSS3 中的一个模块，通过@font-face 可以定义一种全新的字体，然后就可以通过 css 属性 font-family 来使用这个字体了，即使操作系统没有安装这种字体，网页上也会正常显示出来。 

12、div+css布局较table布局有什么优点？
（1）精简代码
网站使用div+css布局使代码很是精简，css文件可以在网站的任意一个页面进行调用，而若使用table表格修改部分页面却是显得很麻烦。
（2）提高浏览器的访问速度
（3）浏览器兼容性
Div+css相比table布局，更容易出现多种浏览器不兼容的问题，主要原因是各种浏览器对web的默认值不同。

13、CSS可以继承的属性有：font-size,font-family,color
不可以继承的属性有：border padding margin width height
可继承的样式： font-size font-family color, UL LI DL DD DT
不可继承的样式：border padding margin width height
优先级就近原则，同权重情况下样式定义最近者为准载入样式以最后载入的定位为准;优先级为: !important > id > class > tag ； important 比 内联优先级高


14、css引入的方式有哪些？link和@import的区别是？
（1）内联方式，直接在html标签中的style属性中添加css
（2）嵌入方式,在html头部中的<style>标签下书写css代码
（3）链接方式，在html的头部的<head>标签中引入外部的css
（4）导入方式,导入方式指的是使用CSS规则引入外部css文件

15、px和em的区别
px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。
em得值不是固定的，并且em会继承父级元素的字体大小。
    rem是CSS3新增的一个相对单位，可以理解为"root em"，相对于根节点html的字体大小来计算的，chrome/firefox/IE9+支持。任意浏览器的默认字体高都是16px，所以未经调整的浏览器都符合: 1rem=16px。
16、css3有哪些新特性？
1）CSS3 实现圆角（border-radius:8px;），
2）阴影（box-shadow:10px）,
3）对文字加特效（text-shadow）,
4）线性渐变（gradient），
5）旋转（transform）,
6）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转，缩放，定位，倾斜 ,
7）增加了更多的 css 选择器 ,
8）多背景 rgba ,
17、IE浏览器css浮动与兼容性问题
浮动之后，需要清除浮动才不会产生问题。现在主流方法是在浮动元素的父级添加一个class，然后父级添加一个class=“clear”即可。

18、垂直水平居中的方法
（1）绝对定位：top:50%; left:50%; margin-left: -width/2; margin-top: -height/2;
（2）绝对定位：left:50%; top:50%; transform:translateX(-50%) translateY(-50%);
（3）flex布局：父元素：display:left; justify-content:center; align-items:center;
（4）Table-cell：父元素：display:table-cell; text-align:center; vertical-align:middle
（5）绝对定位：margin:auto; top:0; bottom:0; left:0; right:0;
20、页面导入样式时，使用link和@import有什么区别？
（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS，定义rel连接属性等作用；而@import是css提供的，只能用于加载css
（2）页面加载时，link会同时被加载，而@import引用的css会等到页面加载完成再加载；
（3）Import是css2.1提出的，只在IE4以上才能被识别，而link是XHTML标签，无兼容问题。
（4）Link支持使用JS控制DOM去改变样式，而@import不支持。

JS
1、基础语法 
Javascript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。
在 ES5 中，变量声明有两种方式，分别是 var 和 function ，var 用于声明普通的变量，接收任意类型，function 用于声明函数。另外，ES6 新增了 let、const、import 和 class 等四个命令，分别用以声明普通变量、静态变量、模块和类 。 
JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(PrimitiveType)。 
原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中(按值访问)。为了便于操作这类数据，ECMAScript提供了 3 个基本包装类型 ：Boolean、Number 和 String。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS内部就会创建一个对应的包装对象从而可以调用一些方法来操作这些数据。 
引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法；但基本类型不可以添加属性和方法。 
Javascript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的toString 方法来判断。JS 中的函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过 new 创建对象时就是构造函数，通过对象调用时就是方法。 
JS 常用的内置对象有 window、Date、Array、JSON、RegExp等，window 是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关的属性和状态，这个后面会讲到，Date 和 Array使用场景最多，JSON 主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。 

2、函数原型链 
JS 是一种基于对象的语言，但在 ES6 之前是不支持继承的，为了具备继承的 
能力，Javascript 在函数对象上建立了原型对象 prototype，并以函数对象为主线，从上至下，在 JS 内部构建了一条 原型链 。
原型链把一个个独立的对象联系在一起，Object则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了 Object，并以 Object 终结。
简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本 
身是否存在，如果不存在就去该对象所在的原型连上去找，直到 Object 对象为 
止，如果都没有找到该属性才会返回 undefined。因此，我们可以通过原型链 
来实现 JS 继承。 

3、函数作用域 
函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内 都是有定义的。因此， JS 中没有块级作用域只有函数作用域 ，这种设计导致 JS 中出现了 变量提升 的问题。简单来说就是，将变量声明提升到它所在作用域的最开始的部分，为了解决变量提升带来的副作用，ES6 新增了let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题。 

4、this 指针 
this 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this 指向规则也不一样：对于普通函数，this 始终指向全局对象 window；对于构造函数，this 则指向新创建的对象；对于 
方法，this 指向调用该方法的对象。另外，Function 对象也提供了 call、apply 和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind 一般在事件回调中使用，而 call 和 apply 
的区别只是参数的传递方式不同。如果往深的去理解，无论什么函数，this 是否被改变， 本质上，this 均指向触 发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。 

5、new 操作符 
函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()。JS 中的函数即可以是函数，也可以是方法，还可以是构造函数。 当使用 new 来创建对象时，该函数就是构造函数，JS 将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型 prototype 中的方法和属性。 

5、闭包 
闭包是指有权访问一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。闭包是一个具有独立作用域的静态执行环境。和函数作用域不同的是，闭包的作用域是静态的，可以永久保存局部资源，而函数作用域只存在于运行时，函数执行结束后立即销毁。因此，闭包可以形成一个独立的执行过程，
闭包的特性是在函数内部再嵌套函数，内部函数可以引用外层的参数和变量
闭包有三个特性：
（1）函数嵌套函数
（2）函数内部可以引用外部的参数和变量
（3）参数和变量不会被垃圾回收机制回收
闭包常见用途：
（1）创建特权方法用于访问控制
（2）事件处理程序及回调
使用闭包的注意点
1）滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2）会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

6、单线程和异步队列 
Javascript 是单线程语言，在浏览器中，当 JS 代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境在栈中采用后进先出(LIFO)的顺序来执行代码块，以保证所有的函数能按照正确的顺序被执行。 
但在浏览器中，有一些任务是非常耗时的，比如 ajax 请求、定时器、事件等，为了保证非耗时任务不受影响，Javascript 在执行环境中维护了一个异步队列(也叫工作线程)，并将这些耗时任务放入队列 
中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，主线程才会去检查异步队列中的任务是否需要开始执行。 
JS 中的 setTimeout 和 setInterval 就是典型的异步操作，它们会被放入异步 
队列中等待，即使 setTimeout(0)也不会被立即执行，需要等到当前同步任务结束后才会被执行。
 
7、异步通信 Ajax 技术 
Ajax 是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest，通过该对象可以创建一个 Ajax 请求。Ajax 请求是一个耗时的异步操作，当请求发出以后，Ajax 提供了两个状态位来描述请求在不同阶段的状态，这两个状态位分别是 readyState 和 status ，readyState 通过5 个状态码来描述一个请求的 5 个阶段： 
0 - 请求未发送，初始化阶段 
1 - 请求发送中，服务器还未收到请求 
2 - 请求发送成功，服务器已收到请求 
3 - 服务器处理完成，开始响应请求，传输数据4 - 客户端收到请求，并完成了数据下载，生成了响应象 	status 用于描述服务端对请求处理的情况，200 表示正确响应了请求，404表示服务器找不到资源，500 代表服务器内部异常等等。 
Ajax 对象还可以设置一个 timeout 值，代表超时时间，切记：timeout 只会影响readyState，而不会影响 status，因为超时只会中断数据传输，但不会影响服 务器的处理结果。
status 是 200，但 response 里却没有数据，这种情况就是服务器正确响应了请求，但数据的下载被超时中断了。为了防止 XSS 攻击，浏览器对 Ajax 请求做了限制，不允许 Ajax 跨域请求服务器，只允许请求和当前地址同域的服务器资源。但不限制脚本和标签发送跨域请求，比如script 和 img 标签，因此可以利用脚本跨域能力来实现跨域请求，即 JSONP的原理。 
JSONP 虽然可以解决跨域问题，但只能是 get 请求，并且没有有效的错误捕获机制，为了解决这个问题，XMLHttpRequest Level2 提出了CORS 模型，即 跨域资源共享， 它不是一个新的 API，而是一个标准规范，当浏览器发现该请求需要跨域时，就会自动在头信息中添加一个 Origin字段，用以说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。随着移动端的快速发展，Web 技术的应用场景正在变得越来越复杂， 关注点分离 原则在系统设计层面就显得越来越重要，而 XMLHttpRequest 是 
Ajax 最古老的一个接口，因而不太符合现代化的系统设计理念。因此，浏览器提供了一个新的 Ajax 接口，即 Fetch API ，Fetch API 是基于 Promise 思想设计的，更符合关注点分离原则。 

8、模块化 
在 ES6 之前，为了实现 JS 模块化编程，社区制定了一些模块加载方案，最主要有CMD 和 AMD 两种，分别以 commonjs 和 requirejs 为代表。ES6 在语言标准的层面上，实现了模块化编程，其设计思想是，尽量静态化，使得编译时就能确定模块的依赖关系，即编译时加载，而 CMD 和 AMD 是在运行时确定依赖关系，即运行时加载。 

9、ES6熟悉吗，说几个ES6的新增方法
ES6 是 ECMAScript 6.0 的简写，即 Javascript 语言的下一代标准，它的目标是让 JS 能够方便的开发企业级大型应用程序，ES6 规范中，比较重大的变化有以下几个方面： 
（1）新增 let、const 命令。 let用来声明变量，const用来声明常量，let和const都是块级作用域，和 var 相比，let 声明的变量不存在变量提升问题，但没有改变 JS 弱类型的特点，依然可以接受 任意类型变量的声明；const 声明的变量不允许在后续逻辑中改变，提高了 JS 语法的严谨性。 
（2）新增解构赋值、rest 语法、箭头函数，这些都是为了让代码看起来更简洁，而 包装的语法糖。 
（3）新增模块化，这是 JS 走向规范比较重要的一步，让前端更方便的实现工程化。
ES6标准中，JavaScript原生支持模块(module)了。这种将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口。import用于在一个模块中加载另一个含有export接口的模块。import和export命令只能在模块的顶部，不能在代码块之中。 
（4）新增类和继承的概念，配合模块化，JS 也可以实现高复用、高扩展的系统架构。 
（5）新增模板字符串功能，高效简洁，结束拼接字符串的时代。 
（6）新增 Promise 对象，解决异步回调多层嵌套的问题。 
（7）ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。
（8）新增箭头函数。写法：函数名=(形参)=>{……}    当函数体中只有一个表达式时，{}和return可以省略，当函数体中形参只有一个时，()可以省略。特点：箭头函数中的this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window。
（9）新增for...of  循环它是遍历所有数据结构的统一的方法。for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串.
10、说出至少5个ES6的新特性，并简述它们的作用。（简答题）
（1）let关键字，用于声明只在块级作用域起作用的变量；const关键字，用于声明一个常量；
（2）结构赋值，一种新的变量赋值方式。常用于交换变量值，提取函数返回值，设置默认值；
（3）Symbol数据类型，定义一个独一无二的值；
（4）Proxy代理，用于编写处理函数，来拦截目标对象的操作；
（5）for...of遍历，可遍历具有iterator接口的数据结构；
（6）Set结构，存储不重复的成员值的集合；
（7）Map结构，键名可以是任何类型的键值对集合；
（8）Promise对象，更合理、规范地处理异步操作；
（9）Class类定义类和更简便地实现类的继承；

11、Set 怎么去重
ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数，如：
let array = [1, 1, 1, 1, 2, 3, 4, 4, 5, 3];
let set = new Set(array);
console.log(set); // 此时打印的是set 结构 Set(5) {1, 2, 3, 4, 5}

12、promise 实现原理? promise的三种状态 
Promise是异步编程的一种解决方案，实际上解决jquery的ajax回调地域(解决层层嵌套),将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。
Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。then()方法接收两个参数：onResolve和onReject，分别代表当前 promise 对象在成功或失败时。	promise两个特点:
（1）对象的状态不受外界影响
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。
promise 缺点: 无法取消promise,如果不设置回调函数,promise内部抛出错误，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

13、es6继承和es5继承的区别

14、箭头函数和普通函数的区别
两者最关键的区别就是this指向的区别，普通函数中的this指向函数被调用的对象，因此不同的调用者，this的值是不同的。而箭头函数中并没有自己的this，箭头函数中this是固定的，它指向定义该函数时所在的对象。
箭头函数：
let fun = () => {
console.log('lalalala');
}
普通函数：
function fun() {
    console.log('lalla');
}
箭头函数相当于匿名函数，并且简化看函数的定义。箭头函数有两种格式，一种只包含一个表达式，连{...}和return都省略掉了。还有一种可以包含多条语句，在这时候不能省略{...}和return
箭头函数是匿名函数，不能作为构造函数，不能使用new，箭头函数不能绑定arguments，取而代之用rest参数解决。
箭头函数不绑定this,会捕获其在的上下文的this的值，作为自己的this值。
箭头函数通过call()或apply()方法调用一个函数时，只传入了一个参数，对this并没有影响。

15、对async 和 await的认识

16、进程和线程的区别
进程是具有独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
线程是进行的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。
一个线程可以创建和撤销另一个线程；同一个线程中的多个线程之间可以并发执行。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
简而言之，一个程序至少有一个进程，一个进程至少有一个线程。

17、js是单线程还是多线程？
Js的单线程与它的用途有关，作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。

18、js既然是单线程，怎么实现异步？
JS实现异步编程有四种方法，第一种是回调函数，采用这种方式，把同步操作变成了异步操作，回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护。第二种是事件监听，任务的执行不取决于代码的顺序，而取决于每个事件是否发生。这种方法的优点是比较任意理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去耦合，实现模块化。第三种发布/订阅，假定存在一个信号中心，某个任务完成就向信号中心发布一个信号，其他任务可以向信号中心订阅这个信号，从而找到自己什么时候开始执行。第四种promise对象，它的思想是每个异步任务返回一个promise对象，该对象有一个then方法，允许指定回调函数。

19、浏览器的内核分别是什么?
IE: trident内核
Firefox：gecko内核
Safari：webkit内核
Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核
Chrome：Blink(基于webkit，Google与Opera Software共同开发)

20、cookies，sessionStorage和localStorage的区别？
共同点：都是保存在浏览器端，且是同源的。
区别：cookies是为了标识用户身份而存储在用户本地终端上的数据，始终在同源http请求中携带，即cookies在浏览器和服务器间来回传递，而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。
存储大小的限制不同。cookie保存的数据很小，不能超过4k，而sessionstorage和localstorage保存的数据大，可达到5M。
数据的有效期不同。cookie在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。sessionstorage仅在浏览器窗口关闭之前有效。localstorage始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。
作用域不同。cookie在所有的同源窗口都是共享；sessionstorage不在不同的浏览器共享，即使同一页面；localstorage在所有同源窗口都是共享。

21、iframe框架有那些优缺点？
优点：
（1）iframe能够原封不动的把嵌入的网页展现出来。
（2）如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
（3）网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
（4）如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。
缺点：
搜索引擎的爬虫程序无法解读这种页面框架结构中出现各种滚动条使用框架结构时，保证设置正确的导航链接。iframe页面会增加服务器的http请求。

22、如何实现浏览器内多个标签页之间的通信?
WebSocket SharedWorker
也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。
注意：Safari 在无痕模式下设置 localstorge 值时会抛出QuotaExceededError 的异常

23、webSocket如何兼容低浏览器？
Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR引用WebSocket.js这个文件来兼容低版本浏览器。

24、网页验证码是干嘛的，是为了解决什么安全问题？
区分用户是计算机还是人的程序;可以防止恶意破解密码、刷票、论坛灌水；

25、title与h1的区别、b与strong的区别、i与em的区别？
title属性没有明确意义，只表示标题；h1表示层次明确的标题，对页面信息的抓取也有很大的影响。
strong标明重点内容，语气加强含义；b是无意义的视觉表示
em表示强调文本；i是斜体，是无意义的视觉表示
视觉样式标签：b i u s
语义样式标签：strong em ins del code

26、元素的alt和title有什么异同？
在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。

27、优化图片加载的方法
（1）懒加载；（2）在页面载入的时候将页面上的img标签的src指向一个小图片，把真实地址存放在一个自定义属性中。如果图片为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张下载。（3）如果图片为css图片，可以使用cssSprite,SVGsprite,Iconfont,Base64等技术。
（4）如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。（5）如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。

28、Js面向对象的几种方式
（1）对象的字面量 var obj = {}
（2）创建实例对象 var obj = new Object();
（3）构造函数模式 function fn(){} , new fn();
（4）工厂模式：用一个函数，通过传递参数返回对象。function fn(params){var obj =new Object();obj.params = params; return obj;},fn(params);
（5）原型模式：function clock(hour){} fn.prototype.hour = 0; new clock();
首先，每个函数都有一个prototype(原型)属性，这个指针指向的就是clock.prototype对象。而这个原型对象在默认的时候有一个属性constructor，指向clock，这个属性可读可写。而当我们在实例化一个对象的时候，实例newClock除了具有构造函数定义的属性和方法外（注意，只是构造函数中的）,还有一个指向构造函数的原型的指针，ECMAScript管他叫[[prototype]]，这样实例化对象的时候，原型对象的方法并没有在某个具体的实例中，因为原型没有被实例。

29、JQuery中有几种类型的选择器
（1）层叠选择器$(“form input”)
（2）基本过滤选择器 :first :last :not()
（3）内容过滤选择器:odd:eq():animated
（4）可视化过滤选择器 :hidden :visible
（5）属性过滤选择器：div[id]
（6）子元素过滤选择器:first一child :last一child :only :child
（7）表单元素过滤选择器 :enabled :disabled :checked :selected
（8）id,类，类型,元素…

30、Ajax同步和异步的区别，如何解决跨域问题
同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.
同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。
异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。

31、js放在html的不同位置有什么区别吗？
如果使用window.onload函数，将js代码放在其中，则放在哪里都是一样的，因为都是在body加载完再执行的，如果不使用window.onload函数,放在head中的话，代码不会被执行，这是因为html执行顺序，确切的说是js的执行顺序，HTML从上运行到 的时候进入test.js文件。前面的不会运行，也就是被function包起来的不会被运行，这个时候就执行最后一句。去页面中取元素。但是这个时候，HTML页面并没有加载完。所以找不到元素，就会报错。

32、ajax和jsonp的区别是？
实现方法完全不一样。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加。

33、content-type是什么？有什么作用？
Content-Type是显示字符集的设定一般在meta信息中，这个功能就是通过读取HTML页面META标签 的Content-Type属性而得知需要使用哪种字符集显示该页面的。

34、block, inline-block, inline三者之前有什么区别？
Block独占一行，可以设置宽高，自动填满父元素高度，可以设置margin和padding
ineLine-block与其他元素占一行，可以设置宽高，，可以设置margin和padding
inline不会独占一行，不可以设置宽高，可以设置margin padding。

35、Object.js()与原来的比较操作符“===”、“==”的区别
两等号判等，会在比较时进行类型转换。
三等号判等比较严格，比较时不进行隐形类型转换，类型不同会返回false。
Object.js()在三等号判等的基础上特别处理了NAN，-0，+0，保证-0和+0不再相同，当Object.js(NAN,NAN)会返回true。
Object.js应该被认为有特殊的用途，二不能用它认为比其他更宽松或严格。

36、变量的作用域
变量的作用域分类：全局变量和局部变量。
特点：
（1）函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。
（2）函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

37、什么是跨域？跨域请求资源的方法有哪些？
由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域
跨域请求资源的方法：(1)porxy代理；(2)CORS 【Cross-Origin Resource Sharing】；(3) jsonp

38、比较typeof与instanceof？
相同点：js中typeof与instanceof常用来判断一个变量是否为空，或者是什么类型的。
Typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。
细节：
（1）typeof一般只能返回如下几个结果：number、boolean、string、function、object、undefined
（2）typeof来获取一个变量是否存在，如if(typeof a!=“undefined”){alert(“ok”)},而不要去使用if(a)因为如果a不存在（未声明）则会出错。
（3）对于Array,Null等特殊对象使用typeof一律返回object，这正是typeof的局限性。
Instanceof定义和用法：instanceof用于判断一个变量是否属于某个对象的实例。

39、Ajax的优缺点及工作原理？
定义和用法:
AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。
传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。
优点：
（1）减轻服务器的负担,按需取数据,最大程度的减少冗余请求
（2）局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验
（3）基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离
缺点：
（1）AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.
（2）AJAX只是局部刷新,所以页面的后退按钮是没有用的.
（3）对流媒体还有移动设备的支持不是太好等
AJAX的工作原理：
（1）创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）
（2）判断数据传输方式(GET/POST)
（3）打开链接 open()
（4）发送 send()
（5）当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数

40、请指出document load和document ready的区别？
共同点：这两种事件都代表的是页面文档加载时触发。
异同点：
ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。
onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。

jquery
1、jQuery 库中的 $() 是什么？
$() 函数是 jQuery() 函数的别称。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。

2、如何找到所有 HTML select 标签的选中项？
$('[name=selectname] :selected')

3、$(this) 和 this 关键字在 jQuery 中有何不同？
$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。
而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。

4、jquery怎么移除标签onclick属性？
获得a标签的onclick属性: $("a").attr("onclick")
删除onclick属性：$("a").removeAttr("onclick");
设置onclick属性：$("a").attr("onclick","test();");

5、jquery中addClass,removeClass,toggleClass的使用。
$(selector).addClass(class)：为每个匹配的元素添加指定的类名
$(selector).removeClass(class)：从所有匹配的元素中删除全部或者指定的类，删除class中某个值；
$(selector).toggleClass(class)：如果存在（不存在）就删除（添加）一个类
$(selector).removeAttr(class);删除class这个属性；

6、JQuery有几种选择器?
(1)、基本选择器：#id，class,element,*;
(2)、层次选择器：parent > child，prev + next ，prev ~ siblings
(3)、基本过滤器选择器：:first，:last ，:not ，:even ，:odd ，:eq ，:gt ，:lt
(4)、内容过滤器选择器： :contains ，:empty ，:has ，:parent
(5)、可见性过滤器选择器：:hidden ，:visible
(6)、属性过滤器选择器：[attribute] ，[attribute=value] ，[attribute!=value] ，[attribute^=value] ，[attribute$=value] ，[attribute*=value]
(7)、子元素过滤器选择器：:nth-child ，:first-child ，:last-child ，:only-child
(8)、表单选择器： :input ，:text ，:password ，:radio ，:checkbox ，:submit 等；
(9)、表单过滤器选择器：:enabled ，:disabled ，:checked ，:selected

7、jQuery中的Delegate()函数有什么作用？
   delegate()会在以下两个情况下使用到：
 （1）、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：
$("ul").delegate("li", "click", function(){ $(this).hide(); });
（2）、当元素在当前页面中不可用时，可以使用delegate()

8、$(document).ready()方法和window.onload有什么区别？
 (1)、window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。
 (2)、$(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。

10、 jquery中$.get()提交和$.post()提交有区别吗？
相同点：都是异步请求的方式来获取服务端的数据；
异同点：
（1）、请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。
（2）、参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。
（3）、数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多
（4）、安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。

11、jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？
(1)、bind 【jQuery 1.3之前】
定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；
语法：bind(type,[data],function(eventObject))；
特点：
　　(1)、适用于页面元素静态绑定。只能给调用它的时候已经存在的元素绑定事件，不能给未来新增的元素绑定事件。
　　(2)、当页面加载完的时候，你才可以进行bind()，所以可能产生效率问题。
实例如下：$( "#members li a" ).bind( "click", function( e ) {} );
(2)、live 【jQuery 1.3之后】
定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；
语法：live(type, [data], fn);
特点：
　　(1)、live方法并没有将监听器绑定到自己(this)身上，而是绑定到了this.context上了。
　　(2)、live正是利用了事件委托机制来完成事件的监听处理，把节点的处理委托给了document，新添加的元素不必再绑定一次监听器。
　　(3)、使用live（）方法但却只能放在直接选择的元素后面，不能在层级比较深，连缀的DOM遍历方法后面使用，即$(“ul”").live...可以，但$("body").find("ul").live...不行； 
实例如下：$( document ).on( "click", "#members li a", function( e ) {} );
(3)、delegate 【jQuery 1.4.2中引入】
定义和用法：将监听事件绑定在就近的父级元素上
语法：delegate(selector,type,[data],fn)
特点：
　　(1)、选择就近的父级元素，因为事件可以更快的冒泡上去，能够在第一时间进行处理。
　　(2)、更精确的小范围使用事件代理，性能优于.live()。可以用在动态添加的元素上。
实例如下：
$("#info_table").delegate("td","click",function(){/*显示更多信息*/});
$("table").find("#info").delegate("td","click",function(){/*显示更多信息*/});
(4)、on 【1.7版本整合了之前的三种方式的新事件绑定机制】
定义和用法：将监听事件绑定到指定元素上。
语法：on(type,[selector],[data],fn)
实例如下：$("#info_table").on("click","td",function(){/*显示更多信息*/});参数的位置写法与delegate不一样。
说明：on方法是当前JQuery推荐使用的事件绑定方法，附加只运行一次就删除函数的方法是one()。
 总结：.bind(), .live(), .delegate(),.on()分别对应的相反事件为：.unbind(),.die(), .undelegate(),.off()

VUE

1、v-model原理解析
v-model可以实现双向数据绑定，根据官方文档介绍，v-model本质上就是语法糖，即利用v-model绑定数据后，其实就是既绑定了一个数据，又添加了一个input事件监听。
当在input元素中使用v-model实现双向数据绑定，其实就是在输入的时候触发元素的input事件，通过这个语法糖，也能够实现父子组件数据的双向绑定。

2、什么是MVVM？
MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象（桥梁）。
在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。
3、mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？
mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多的场景，更加便捷
4、vue的优点是什么？
（1）低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
（2）可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。
（3）独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
（4）可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。

5、组件之间的传值？
（1）父组件与子组件传值
	父组件通过标签上面定义传值：eg='data'父组件中 data(){return {data:'egdata'}}
子组件通过props方法接受数据 props:['eg'] 在props 中添加了元素之后，就不需要在 data 中再添加变量了。
（2）子组件向父组件传递数据
	子组件通过$emit方法传递参数。
（3）子组件向子组件传递数据
Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。
为了便于开发，Vue 推出了一个状态管理工具 Vuex，可以很方便实现组件之间的参数传递。

6、路由之间跳转
声明式（标签跳转）、编程式（js跳转）
①直接修改地址栏中的路由地址 ②通过router-link实现跳转

7、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？
第一步：在components目录新建你的组件文件（如：indexPage.vue），script一定要export default {}
第二步：在需要用的页面（组件）中导入：import indexPage from '@/components/indexPage.vue'
第三步：注入到vue的子组件的components属性上面,components:{indexPage}
第四步：在template视图view中使用，例如有indexPage命名，使用的时候则index-page

8、vuex是什么？怎么使用？哪种功能场景使用它？
vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车。

9、vuex有哪几种属性？
有五种，分别是State、Getter、Mutation 、Action、Module
（1）vuex的State特性
①Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data
②state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
③它通过mapState把全局state 和getters 映射到当前组件的computed 计算属性中
（2）vuex的Getter特性
①getters 可以对State进行计算操作，它就是Store的计算属性
②虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用
③如果一个状态只在一个组件内使用，是可以不用getters
（3）vuex的Mutation特性
	Action 类似于mutation，不同在于：Action 提交的是mutation，而不是直接变更状态；Action 可以包含任意异步操作。

10、不用Vuex会带来什么问题？
（1）可维护性会下降，想修改数据要维护三个地方；
（2）可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；
（3）增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。

11、v-show和v-if指令的共同点和不同点
（1）v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏
（2）v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果

12、如何让CSS只在当前组件中起作用
将当前组件的<style>修改为<style scoped>

13、<keep-alive></keep-alive>的作用是什么?
<keep-alive></keep-alive> 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。

14、指令v-el的作用是什么?
提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例.

15、、请列举出3个Vue中常用的生命周期钩子函数
（1）created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见。
（2）mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当mounted 被调用时vm.$el 也在文档内。
（3）activated: keep-alive组件激活时调用

16、active-class是哪个组件的属性？
vue-router模块的router-link组件。

17、怎么定义vue-router的动态路由以及如何获取传过来的动态参数？
在router目录下的index.js文件中，对path属性加上/:id。
	使用router对象的params.id。

18、vue-router有哪几种导航钩子？
三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
第二种：组件内的钩子；
第三种：单独路由独享组件

19、生命周期相关面试题
总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
·创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。
·载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
·更新前/后：当data变化时，会触发beforeUpdate和updated方法。
·销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
（1）什么是vue生命周期
Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是Vue 的生命周期。
（2）vue生命周期的作用是什么
它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。
（3）第一次页面加载会触发哪几个钩子
第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子
（4）DOM渲染在哪个周期中就已经完成
DOM 渲染在 mounted 中就已经完成了。
（5）简单描述每个周期具体适合哪些场景
生命周期钩子的一些使用方法：
·beforecreate : 可以在这加个loading事件，在加载实例时触发
·created :初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
·mounted : 挂载元素，获取到DOM节点
·updated : 如果对数据统一处理，在这里写上相应函数
·beforeDestroy : 可以做一个确认停止事件的确认框
·nextTick : 更新数据后立即操作dom

20、说出至少4种vue当中的指令和它的用法？
v-if：判断是否隐藏；v-for：数据循环；v-bind:class：绑定一个属性；v-model：实现双向绑定

21、vue-loader是什么？使用它的用途有哪些？
解析.vue文件的一个加载器。（深入理解见https://www.jb51.net/article/115480.htm）
用途：js可以写es6、style样式可以scss或less、template可以加jade等
根据官网的定义，vue-loader 是 webpack 的一个 loader，用于处理 .vue 文件。
其次，使用vue-cli脚手架，作者已经配置好了基本的配置，开箱及用，你需要做的就是npm install 安装下依赖，然后就可以开发业务代码了。当然，如果你想进阶，最好熟悉下vue-loader的具体配置，而不要依赖脚手架

22、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？
答：css的预编译。（scss是sass的一个升级版本，完全兼容sass之前的功能，又有了些新增能力，最主要的就是sass是靠缩进表示嵌套关系，scss是花括号）
使用步骤：
第一步：先装css-loader、node-loader、sass-loader等加载器模块
第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss
第三步：在同一个文件，配置一个module属性
第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”
特性:
·可以用变量，例如（$变量名称=值）；
·可以用混合器，混入@mixin 可以传变量
·可以嵌套
　　　继承@extend不可以传变量，相同样式直接继承，不会造成代码冗余；基类未被继承时，也会被编译成css代码

23、为什么使用key？
当有相同标签名的元素切换时，需要通过key 特性设置唯一的值来标记以让Vue 区分它们，否则Vue 为了效率只会替换相同标签内部的内容。

24、为什么避免v-if和v-for用在一起
当Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算v-for。

25、VNode是什么？虚拟 DOM是什么？ 详情见 https://www.jb51.net/article/105221.htm
Vue在页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟DOM”是由Vue 组件树建立起来的整个VNode 树的称呼。

26、active-class是哪个组件的属性？嵌套路由怎么定义？
vue-router模块的router-link组件。
嵌套路由顾名思义就是路由的多层嵌套。一级路由里面使用children数组配置子路由，就是嵌套路由。

27、mint-ui是什么？怎么使用？说出至少三个组件使用方法？htthttps://www.cnblogs.com/stella1024/p/7771334.html
基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper
 
28、v-model是什么？怎么使用？vue中标签怎么绑定事件？
可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：<input @click=doLog() />
 
29、axios是什么？怎么使用？描述使用它实现登录功能的流程？
答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中
 Vue.js 1.0 我们常使用 vue-resource (官方ajax库), Vue 2.0 发布后作者宣告不再对 vue-resource 进行更新， 推荐我们使用 axios (基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用)

30、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？
一个model+view+viewModel框架，数据模型model，viewModel连接两个区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多的场景，更加便捷
 
31、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？
全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives
钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）
钩子函数参数：el、binding

32、vue-router是什么？它有哪些组件？
vue用来写路由一个插件。router-link、router-view
 
33、导航钩子有哪些？它们有哪些参数？
导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave
参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种。
 
34、Vue的双向数据绑定原理是什么？
答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：
第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
①在自身实例化时往属性订阅器(dep)里面添加自己
②自身必须有一个update()方法
③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

35、请说下封装vue组件的过程？
首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。
然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。
 
36、你是怎么认识vuex的？
vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。
通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。
应用级的状态集中放在store中；改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。

37、请说出vue.cli项目中src目录每个文件夹和文件的用法？
assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件
 
38、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？
第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default 
第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’
第三步：注入到vue的子组件的components属性上面,components:{smithButton}
第四步：在template视图view中使用，<smith-button>  </smith-button>
问题有：smithButton命名，使用的时候则smith-button。
 
39、聊聊你对Vue.js的template编译的理解？ https://www.jianshu.com/p/e1669afa30b8 
简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
详情步骤：
首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 抽象语法树  即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）
组件的设计原则
(1)页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块) 
(2)每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中) 
(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑) 
(3)页面不过是组件的容器，组件可以嵌套自由组合成完整的页面

40、Vue实现数据双向绑定的原理：Object.defineProperty（）
vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。
vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。

41、Vue的路由实现：hash模式 和 history模式
hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；
特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。
hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。
history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。
history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”
42、对keep-alive 的了解？
keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。
参数解释
include - 字符串或正则表达式，只有名称匹配的组件会被缓存
exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存
include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。

43、$route和$router的区别
答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

44、vue.js的两个核心是什么？
数据驱动、组件系统

45、vue常用的修饰符？
	.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用

46、.vue等单页面应用及其优缺点
优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。

47、vue原理间接
vue.js中有两个核心功能：响应式数据绑定，组件系统。
在官方文档中指出，当你把一个普通的js对象传给vue实例的data选项，vue将遍历此对象所有的属性，并使用object.defineProperty把这些属性全部转为getter/setter.
这些getter/setter对用户来说是不可见的，但在内部它们让vue追踪依赖，在属性被访问和修改时通知变化。
每个组件实例都有相应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。
Getter：主要是获取到对应的键值，将原来的getter和setter提取出来
Setter:主要是对相同的值的拦截，然后对于嵌套对象的重新observe，这里之所以会重新observe是因为在每次响应了数据变化后，会清除所有的依赖，因此要重新建立。

微信小程序
1、简单描述下微信小程序的相关文件类型？
微信小程序项目结构主要有四个文件类型，如下：
（1）WXML是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。
（2）WXSS是一套样式语言，用于描述WXML的组件样式。
（3）Js逻辑处理，网络请求。
（4）Json小程序设置，如页面注册，页面标题及tabBar。
（5）App.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航样式，配置默认标题。
（6）app.wxss

2、你是怎么封装微信小程序的数据请求的？
（1）将所有的接口放在统一的js文件中导出。
（2）在app.js中创建封装请求数据的方法。
（3）在子页面中调用封装的方法请求数据。

3、有哪些参数传值的方法？
（1）给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或param参数获取。但data-名称不能有大写字母和不可以存放对象。
（2）设置id的方法标识来传值通过e.currentTarget.id获取设置的id的值，然后通过设置全局对象的方法来传递数值。
（3）在navigator中添加参数传值

4、你使用过哪些方法，来提高微信小程序的应用速度？
（1）提高页面加载速度；（2）用户行为预测；（3）减少默认data的大小；（4）组件方案。

5、小程序与原生App哪个好？
小程序除了拥有公众号的低开发成本、低获客成本以及无需下载等优势，在服务请求延时与用户使用体验都得到了较大幅度的提升，使得其能够承受复杂的服务功能以及获得更好的用户体验。

6、简述微信小程序原理？
微信小程序采用js、wxml、wxss三种技术进行开发，从技术讲和现在的前端开发差不多，但深入挖掘的话却有所不同。
Js：首先js的代码是运行在微信app中的，并不是运行在浏览器中，因此一些h5技术的应用，需要微信app提供对应的API支持，而这限制了h5技术的应用，且其不能成为严格的h5，可以称其为伪h5，同理，微信提供独有的某些API，H5也不支持或支持的不是特别好。
Wxml: wxml微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。
Wxss: wxss具有css的大部分特性，但斌不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。
微信框架，是数据驱动的架构模式，它的ui和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。
小程序分为两个部分webview和appService。其中webview主要用来展现ui,appservice有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现ui的渲染、事件的处理。

7、分析下微信小程序的优劣势
优势：
（1）无需下载，通过搜索和扫一扫就可以打开；
（2）良好的用户体验：打开速度快；
（3）开发成本要比App要低；
（4）安卓上可以添加到桌面，与原生App差不多。
（5）为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。
劣势：
（1）限制较多。页面大小不能超过1M.不能打开超过5个层级的页面。
（2）样式单一。小程序的部分组件已经是成型的了，样式不可以修改。
（3）推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。
（4）依托于微信，无法打开后台管理功能。

8、微信小程序于H5的区别？
（1）运行环境不同
传统的HTML5的运行环境是浏览器，包括webview,而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。
（2）开发成本不同
只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的bug
（3）获取系统级权限的不同
系统级权限都可以和微信小程序无缝衔接。
（4）应用在生产环境的运行流畅度

其他

1、简单介绍一下你做过的移动端APP项目研发流程
答：我的移动端APP项目：《硅谷外卖》，这是一个基于vue2.0+webpack+ES6的一个前后台分离的项目，后台负责处理前台应用提交的请求，并给前台应用返回json数据，前台应用负责展现数据，与用户交互，与后台应用交互，可以实现用户的浏览，登录，选购，搜索等功能。
基本流程：
首先对照一般的外卖APP编写整个app的静态页面和样式。然后使用vue-cli搭建项目，对项目源码进行目录设计，在SRC文件夹下分出路由文件夹、路由组件文件夹，非路由组件文件夹、模拟数据接口文件夹，vuex相关模块文件夹，入口JS和应用组件等多个文件，将整个APP分为商家、商品、用户、购物车等多个子模块，并分析每个模块的结构，将每个模块相应的代码单独提取出去创建自己的路由组件，在非路由组件下创建底部FooterGuide组件和头部HeaderTop组件，在HeaderTop中使用slot标签进行组件通信。
在商家路由下又分出食物、评价和商家信息。其中，最为复杂的是食物组件，内部使用了另外三个组件，包括购物车组件，购物车操作组件，食物详情组件，第三方库使用的是better-scroll，实现食物列表的上下滑动。
对于登录路由组件，有短信登录和账号密码登录两种，在router文件夹下的index.js文件中注册登录路由。其中的界面相关效果包括登录方式的切换，手机号合法检查，倒计时效果，切换显示或隐藏密码，前台验证提示。前后台交互包括动态一次性短信，动态一次性图形验证码，获取用户信息，实现自动登录，短信登陆，密码登录，退出登录，其中退出登录使用mint-ui。
共有10个api接口，包括经纬度的获取，商家列表，食物分类的获取，一次性验证码，手机号验证，用户登录登出等。
封装ajax请求进行前后台交互。
下载vuex对项目进行管理，
异步显示数据，
对于用户评价
项目的日期处理使用了自定义过滤器和moment

2、前端安全问题以及解决办法？
我觉得主要有六大安全问题包括：
（1）XSS（cross-site scripting）脚本攻击漏洞；
XSS是前端谈论最多的安全问题，通过输入文本或HTML标签中插入js进行脚本攻击。解决办法是在使用HTML进行转换内容的时候，不用innerHTML改用innerText,或者把<script><iframe>等标签替换掉。
（2）CSRF（cross-site request forgery）漏洞；
对于跨站请求伪造，其实就是对网站中的一些表单提交行为被黑客利用，比如网站登录时存到cookie的一些个人信息，当你访问黑客的网站有一段相同代码隐藏div，但你点击的时候会导致你的网站被登录或登出，就是在对别的网站进行操作的时候会对你之前的网站发送请求。
解决办法是增加token验证避免攻击，referer验证对页面来源进行判断。
（3）iframe安全隐患问题；
对于Iframe安全隐患问题，可以使用安全的网站进行嵌入。
（4）本地存储数据问题；
可以对放在cookie中或localStorage中的信息进行加密，或使用base64进行多次加密 和解密。
（5）第三方依赖的安全性问题；
利用自动化工具进行扫描
（6）HTTPS加密传输协议；
对接口请求及网站部署等进行HTTPS加密。

3、最近在学什么？能谈谈你未来3，5年给自己的规划吗？
最近在学习微信小程序开发，正在做一款名为《豆瓣电影》的微信小程序，近期的目标是微信小程序以及react框架。长期计划，在未来的三至五年依旧从事前端开发，但是之后会慢慢从PC端转向移动端开发，毕竟相较于PC端，移动端的优势更大，在人群中手机的普及率远远大于电脑，在拥有相同功能和享受的情况下，我相信大多数人更愿意使用手机在移动端进行操作，无论是发达地区还是不太发达的地区，移动端更符合大众的消费水平和消费习惯，微信小程序的出现更是使得移动端更加方便和美观。

4、移动端（Android IOS）怎么做好用户体验?
答：清晰的视觉线，信息的分组，极致的减法，利用选择代替输入，标签及文字的排布方式，依靠明文解决密码，合理的键盘利用。

5、你对加班的看法？
答：加班就像借钱，原则应当是——救急不救穷
6、你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）
答：“移动开发也称为手机开发，或叫做移动互联网开发。是指以手机、PDA、UMPC等便携终端为基础，进行相应的开发工作，由于这些随身设备基本都采用无线上网的方式，因此，业内也称作为无线开发。”
单纯的说移动端和PC端的区别，简单的概括就是移动端的网页开发比pc端更加开发，更加简单，页面小，装的东西少，css和html写的就少了，交互也简单。

7、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？
答：前端是最贴近用户的程序员，前端的能力就是让产品从90分进化到100分，甚至更好，可以实现界面交互实现界面交互，提升用户体验，比后端、数据库、产品经理、运营、安全都近。

8、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）
答：（1）浏览器会开启一个线程来处理这个请求，对URL分析判断，如果是http协议就按照web方式来处理；
（2）调用浏览器内核中的对应方法，比如webview中localUrl方法；
（3）通过DNS解析获取网址的IP地址，设置UA等信息发出第二个GET请求；
（4）进行HTTP协议会话，客户端发送报头；
（5）进入到web服务器上的web serer
（6）进入到部署好的后端应用，找到对应的请求处理；
（7）处理结束回馈报头，此处若浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致返回304；
（8）浏览器开始下载html文档，同时使用缓存。
（9）文档树建立，根据标记请求所需指定类型的文件，同时设置cookie
（10）页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定，页面显示完成。

9、http状态码有那些？分别代表是什么意思？
答：（1）1**(信息类)：表示接收到请求并且继续处理
2**(响应成功)：表示动作被成功接收、理解和接受
3**(重定向类)：为了完成指定的动作，必须接受进一步处理
4**(客户端错误类)：请求包含错误语法或不能正确执行
5**(服务端错误类)：服务器不能正确执行一个正确的请求
1**(信息类)：表示接收到请求并且继续处理
  	100——客户必须继续发出请求
  	101——客户要求服务器根据请求转换HTTP协议版本

    2**(响应成功)：表示动作被成功接收、理解和接受
  	200——表明该请求被成功地完成，所请求的资源发送回客户端
  	201——提示知道新文件的URL
  	202——接受和处理、但处理未完成
  	203——返回信息不确定或不完整
  	204——请求收到，但返回信息为空
  	205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
  	206——服务器已经完成了部分用户的GET请求

    3**(重定向类)：为了完成指定的动作，必须接受进一步处理
  	300——请求的资源可在多处得到
  	301——本网页被永久性转移到另一个URL
  	302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
  	303——建议客户访问其他URL或访问方式
  	304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
  	305——请求的资源必须从服务器指定的地址得到
  	306——前一版本HTTP中使用的代码，现行版本中不再使用
  	307——申明请求的资源临时性删除

    4**(客户端错误类)：请求包含错误语法或不能正确执行
  	400——客户端请求有语法错误，不能被服务器所理解
  	401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
  	HTTP 401.1 - 未授权：登录失败
  	　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
  	　　HTTP 401.3 - ACL 禁止访问资源
  	　　HTTP 401.4 - 未授权：授权被筛选器拒绝
  	HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
  	402——保留有效ChargeTo头响应
  	403——禁止访问，服务器收到请求，但是拒绝提供服务
  	HTTP 403.1 禁止访问：禁止可执行访问
  	　　HTTP 403.2 - 禁止访问：禁止读访问
  	　　HTTP 403.3 - 禁止访问：禁止写访问
  	　　HTTP 403.4 - 禁止访问：要求 SSL
  	　　HTTP 403.5 - 禁止访问：要求 SSL 128
  	　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
  	　　HTTP 403.7 - 禁止访问：要求客户证书
  	　　HTTP 403.8 - 禁止访问：禁止站点访问
  	　　HTTP 403.9 - 禁止访问：连接的用户过多
  	　　HTTP 403.10 - 禁止访问：配置无效
  	　　HTTP 403.11 - 禁止访问：密码更改
  	　　HTTP 403.12 - 禁止访问：映射器拒绝访问
  	　　HTTP 403.13 - 禁止访问：客户证书已被吊销
  	　　HTTP 403.15 - 禁止访问：客户访问许可过多
  	　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效
  	HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
  	404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
  	405——用户在Request-Line字段定义的方法不允许
  	406——根据用户发送的Accept拖，请求资源不可访问
  	407——类似401，用户必须首先在代理服务器上得到授权
  	408——客户端没有在用户指定的饿时间内完成请求
  	409——对当前资源状态，请求不能完成
  	410——服务器上不再有此资源且无进一步的参考地址
  	411——服务器拒绝用户定义的Content-Length属性请求
  	412——一个或多个请求头字段在当前请求中错误
  	413——请求的资源大于服务器允许的大小
  	414——请求的资源URL长于服务器允许的长度
  	415——请求资源不支持请求项目格式
  	416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
  	417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。

    5**(服务端错误类)：服务器不能正确执行一个正确的请求
  	HTTP 500 - 服务器遇到错误，无法完成请求
  	　　HTTP 500.100 - 内部服务器错误 - ASP 错误
  	　　HTTP 500-11 服务器关闭
  	　　HTTP 500-12 应用程序重新启动
  	　　HTTP 500-13 - 服务器太忙
  	　　HTTP 500-14 - 应用程序无效
  	　　HTTP 500-15 - 不允许请求 global.asa
  	　　Error 501 - 未实现
    HTTP 502 - 网关错误
    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常

10、你有用过哪些前端性能优化的方法？
答：（1）减少HTTP请求次数；
（2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费；
（3）用innerHTML代替DOM操作；
（4）当需要设置的样式很多时设置className而不是直接使用style
（5）少用全局变量、缓存DOM节点查找的结果
（6）图片预加载
（7）避免在页面的主题布局中使用table;

11、介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
JS引擎则：解析和执行javascript来实现网页的动态效果。
最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

12、undefined和null的区别
Undefined类型只有一个值，即undefined,当声明的变量还未被初始化时，变量默认值为undefined.
null类型也直接有一个值，即null,null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。


13、NAN
NAN属性是代表非数字值的特殊值，该属性用来指示某个值不是数字

14、GET和POST的区别
Get用于获取信息，是无副作用的，是幂等的，且可缓存，post用于修改服务器上的数据，有副作用，非幂等，不可缓存。
GET和POST都是HTTP协议中两种请求方式，而HTTP协议是基于TCP/IP的应用协议，无论GET还是POST，用的都是同一个传输层协议，所以再传输上没有区别。

15、什么叫优雅降级和渐进增强？
优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow
渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；
16、列举IE与其他浏览器不一样的特性？
（1）事件不同之处：
触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；
获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；
阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；
停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；





 
























