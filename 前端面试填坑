
前端基础

1、前端页面由哪三层构成，分别是什么，作用是什么？
Html (结构) : 超文本标记语言, 由 HTML 或 xhtml之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：“这是一个文本段。”
Css (表现) : 层叠样式表 , 由css负责创建。css对“如何显示有关内容”的问题做出了回答。
Js (行为) : 客户端脚本语言 , 内容应该如何对事件做出反应

2、W3C标准  
中文名：万维网联盟
万维网联盟标准不是某一个标准，而是一些列标准的集合。网页主要有三部分组成：结构（Structure）、表现（Presentation）、行为（Behavior）。
对应的标准也有三方面：结构化标准主要包括XHTML和XML，表现标准语言主要包括CSS、行为标准主要包括（如W3C DOM）、ECMAScript等。这些标准大部分是W3C起草发布，也有一是其他标准组织制定的标准，比如ECMAScript（European Computer Manufacturers Association）的ECMAScript的标准。

3、标准规范：
（1）需要声明（DOCTYPE）
DOCTYPE（document type）文档类型的简写，用来说明你用的XHTML或者HTML是什么版本。其中DTD叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的DTD来解释你页面的标识，并展现出来。要建立符合标准的网页，DOCTYPE声明是必不可少的关键组成部分；除非你的XHTML确定了一个正确的DOCTYPE，否则你的标识和css都不会生效。 有过渡的（Transitional）、严格的（strict）、框架的（frameset）
（2）需要定义语言编码
（3）JavaScript定义
Js必须要用<script language="javascript" type="text/javascript">来开头定义，以保证在不支持js的浏览器上直接显示出来。
（4）CSS定义
CSS必须要用<style type=“text/css”>开头来定义，为保证各浏览器的兼容性，在写CSS时请都写上数量单位。
（5）使用注释
（6）所有标签的元素和属性名字都必须使用小写
与HTML不一样，XHTML对大小写是敏感的，<title>和<TITLE>是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。
（7）所有属性值必须用引号括起来（"" ''）双引号或单引号
（8）把所有特殊符号用编码表示
空格为&nbsp; 、小于号（<）&lt、大于号（>）&gt、和号（&）&amp等。
（9）所有属性必须有属性值
XHTML规定所有属性都必须有个值，没有值就是重复本身。
（10）所有的标记都必须有相应的结束标记
双标记：<div></div> 单标记：<img />
（11）所有的标记都必须合理嵌套 
（12）图片添加有意义的alt属性 
图片加载失败时可以用alt属性表明图片内容。同理添加文字链接的title属性，帮助显示不完整的内容显示完整。
（13）在form表单中增加label，以增加用户友好度

结论：
（1）标签规范可以提高搜索引擎对页面的抓取效率，对SEO（搜索引擎优化）很有帮助。
（2）尽量使用外链css样式表和js脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。
（3）样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版。
（4）什么是DOCTYPE
DOCTYPE是document type(文档类型)的简写，用来说明你用的XHTML或者HTML是什么版本。其中的DTD(例如xhtml1-transitional.dtd)叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的DTD来解释你页面的标识，并展现出来。要建立符合标准的网页，DOCTYPE声明是必不可少的关键组成部分；除非你的XHTML确定了一个正确的DOCTYPE，否则你的标识和CSS都不会生效。
（5）名字空间 namespace
<html xmlns="http://www.w3.org/1999/xhtml" lang="gb2312">
通常我们HTML4.0的代码只是<html>，这里的"xmlns"是什么呢？
这个“xmlns”是XHTML namespace的缩写，叫做“名字空间”声明。XHTML是HTML向XML过渡的标识语言，它需要符合XML文档规则，因此也需要定义名字空间。又因为XHTML1.0不能自定义标识，所以它的名字空间都相同，就是"http://www.w3.org/1999/xhtml"。目前阶段我们只要照抄代码就可以了。
（6）定义语言编码
<meta http-equiv=“Content-Type” content=“text/html; charset=gb2312” />
为了被浏览器正确解释和通过W3C代码校验，所有的XHTML文档都必须声明它们所使用的编码语言，我们一般使用gb2312(简体中文)，制作多国语言页面也有可能用Unicode、ISO-8859-1等，根据你的需要定义。
注：如果忘记了定义语言编码,可能就会出现,你在DW(dreamweaver)做完一个页面，第二次打开时所有的中文变成了乱码。
（7）Javascript定义
Js必须要用<script language="javascript" type="text/javascript">来开头定义，而不是原来的<script language=javascript>或干脆直接<script>，并且需要加个注释符<!--   -->，以保证不在不支持js的浏览器上直接显示出代码来。
（8）不要在注释内容中使用“--”
“--”只能发生在XHTML注释的开头和结束，也就是说，在内容中它们不再有效。
例如下面的代码是无效的：<!--这里是注释-----------这里是注释-->
正确的应用等号或者空格替换内部的虚线。<!--这里是注释============这里是注释-->
（9）所有标签的元素和属性的名字都必须使用小写
与HTML不一样，XHTML对大小写是敏感的，<title>和<TITLE>是不同的标签。XHTML要求所有的标签和属性的名字都必须使用小写。
（10）所有的属性必须用引号""括起来
在HTML中，你可以不需要给属性值加引号，但是在XHTML中，它们必须被加引号。
例如：<height=80>必须修改为：<height="80">。
特殊情况，你需要在属性值里使用双引号，你可以用"，单引号可以使用&apos;，例如：<alt="say&apos;hello&apos;">
（11）把所有<和&特殊符号用编码表示
任何小于号（<），不是标签的一部分，都必须被编码为 &lt;
任何大于号（>），不是标签的一部分，都必须被编码为 &gt;
任何与号（&），不是实体的一部分的，都必须被编码为 &amp; 
（12）给所有属性赋一个值
XHTML规定所有属性都必须有一个值，没有值的就重复本身
（13）所有的标记都必须要有一个相应的结束标记
以前在HTML中，你可以打开许多标签，例如<p>和<li>而不一定写对应的</p>和</li>来关闭它们。但在XHTML中这是不合法的。XHTML要求有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个"/"来关闭它。
（14）所有的标记都必须合理嵌套 
同样因为XHTML要求有严谨的结构，因此所有的嵌套都必须按顺序
（15）图片添加有意义的alt属性
（16）在form表单中增加lable，以增加用户友好度 

4、Web前端面试题：对WEB标准以及W3C的理解与认识？
Web标准简单来说可以分为结构、表现和行为，其中结构主要是由html标签组成，或者通俗点来说，在body中我们写入的标签都是为了页面的结构，表现指css样式表，通过css可使页面的结构标签更具美感，行为是指页面和用户具有一定的交互，同时页面结构或者行为发生变化，主要是js组成。
Web标准一般是将该三部分独立分开，使其更具有模块化，但是一般行为发生变化时，一般伴随着结构或表现的变化。
其中，W3C标准对web标准提出了规范化的要求，也即使代码规范，包括：对结构的要求（标签规范可以提高搜索引擎的抓取效率，对SEO很有帮助），标签的字母要小写，标签要闭合，标签不允许随意嵌套。对css和js，尽量使用外链css样式表和js脚本，使结构，表现和行为分为3块，提高页面渲染速度，提高用户体验，尽量少用行间样式表，使结构与表现分离，标签的id和class等属性做到见闻知意。

HTML

1、Doctype的作用？标准模式与兼容模式各有什么区别？严格模式与混杂模式如何区分？它们有何意义?
   （1）<!Doctype>声明位于HTML文档的第一行，处于<html>标签之前。告知浏览器用什么文档来解析这个文档。Doctype不存在或格式不正确会导致文档以兼容模式呈现。
（2）标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为防止站点无法工作。
  （3）严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。
     1）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
     2）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。

2、HTML和XHTML二者有什么区别
HTML和XHTML之间的差别，粗略可以分为两大类比较：一个是功能上的区别，一个是书写习惯上的区别。功能上的区别主要是XHTML可兼容各大浏览器、手机及ipad，并且浏览器能快速正确的编译网页。书写上的区别主要是因为它的语法比较严谨，例如在XHTML中所有标签都必须小写，不能大小写穿插其中，标签号必须成对，所有属性都必须使用双引号。
最主要的区别是：XHTML元素必须被正确的嵌套，XHML元素必须被关闭，标签名必须被小写，XHTML文档必须拥有根元素。

3、新的HTML5文档类型和字符集是？
HTML5文档类型 <!doctype html>
HTML5使用UTF-8字符集 <meta charset="UTF-8">

4、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？
新特性，新增元素：
1）内容元素：article、footer、header、nav、section
2）表单控件：calendar、date、time、email、url、search
3）控件元素：webworker，websockt，Geolocation
移除元素：
1）显现层元素：basefont，big，center，font，s，strike，tt，u
2）性能较差元素：frame，frameset，noframes

4.1、处理兼容问题有两种方式：
1）IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签。
2）使用是html5shim框架
另外，DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构，功能元素来加以区分。

5、HTML5中如何嵌入音频？
HTML5支持MP3、Wav和Ogg格式的音频，下面是在网页中嵌入音频的简单实例：
<audio controls>
<source src="jamshed.mp3" type="audio/mpeg">

6、HTML5如何嵌入视频？
和音频类似，HTML5支持MP4、WebM和Ogg格式的视频，下面是简单实例：
<embed>标签定义嵌入的内容，比如插件。
   <embed type="video/quicktime" src="Fishing.mov">
<source>对于定义多个数据源很有用。
<video width="450" height="340" controls>
   <source src="jamshed.mp4" type="video/mp4">
   <source src="jamshed.mp4" type="video/ogg">
</video>

7、HTML5 Canvas元素有什么用？
Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在HTML上进行图形操作，
<canvas id="canvas1" width="300" height="100"></canvas>

8、HTML5存储类型有什么区别？
1）HTML5能够本地存储数据，在之前都是使用cookie使用的，HTML5提供了下面两种本地存储方案：
2） localStorage用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。
3） sessionStorage 同一个会话的页面才能访问并且当会话结束后数据也会随之销毁，因此sessionStorage不是一种持久化的本地

9、HTML5的文件离线储存怎么使用，工作原理是什么？
在线情况下，浏览器发现HTML头部有manifest属性，它会请求manifest文件，如果是第一次访问，那么浏览器就会根据manifest文件的内容下载相应的资源，并进行离线存储。如果已经访问过并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面。然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不会做任何操作，如果文件改变了，那么就会重新下载文件中的资源，并且进行离线存储。例如，在页面头部加入manifest属性在cache.manifest文件中编写离线存储的资源。

10、简述一下src与href的区别
href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。
src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。

11、label的作用是什么? 是怎么用的?
label标签用来定义表单控件间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label 中有两个属性是非常有用的, FOR和ACCESSKEY。FOR属性功能：表示label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点 

12、BOM 
BOM 是 Browser Object Model的缩写，即浏览器对象模型，当一个浏览器页面初始化时，会在内存创建一个 全局的对象，用以描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型，即 BOM。BOM 的核心对象就是 window，window 对象也是 BOM 的顶级对象，其中包含了浏览器的 6 个核心模块： 
（1）document 
即文档对象，渲染引擎在解析 HTML 代码时，会为每一个元素生成对应的DOM 对象，由于元素之间有层级关系，因此整个 HTML 代码解析完以后，会生成一个由不同节点组成的树形结构，俗称 DOM 树，document 
用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。 
（2）frames - HTML 子框架，
即在浏览器里嵌入另一个窗口，父框架和子框架拥有独立的作用域和上下文。 
（3）history 
以栈(FIFO)的形式保存着页面被访问的历史记录，页面前进即入栈，页面返回即出栈。 
（4）location 
提供了当前窗口中加载的文档相关信息以及一些导航功能。 
（5）navigator 
 用来描述浏览器本身，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。 
（6）screen 
 提供了浏览器显示屏幕的相关属性，比如显示屏幕的宽度和高度，可用宽度和高度。 

13、DOM 系统
DOM 是 Document Object Model 的缩写，即文档对象模型，是所有浏览器公共遵守的标准，DOM 将 HTML 和 XML 文档映射成一个由不同节点组成的树型结构，俗称 DOM 树。其核心对象是 document，用于描述 DOM 树的状态和属性，并提供对应的 DOM 操作 API。随着历史的发展，DOM 被划分为 1 级、2 级、3 级，共 3 个级别： 
1 级 DOM - 由 DOM 核心与 DOM  HTML 两个模块组成。DOM 核心能映射以 XML 为基础的文档结构，允许获取 和操作文档的任意部分。DOM HTML 通过添加 HTML 专用的对象与函数对 DOM 核心进行了扩展。 
2 级 DOM - 鉴于 1 级 DOM 仅以映射文档结构为目标，DOM 2 级面向更为宽广。通过对原有 DOM 的扩展，2 级 DOM 通过对象接口增加了对鼠标和用户界面事件（DHTML 长期支持鼠标与用户界面事件）、范围、遍 
历（重复执行 DOM 文档）和层叠样式表（CSS）的支持。同时也对 DOM 1 的核心进行了扩展，从而可支持 XML 命名空间。 
3 级 DOM - 通过引入统一方式载入和保存文档和文档验证方法对 DOM 进行进一步扩展，DOM3 包含一个名为“DOM 载入与保存”的新模块，DOM 核心扩展后可支持XML1.0 的所有内容，包括 XML Infoset、 XPath、和 XML Base。 浏览器对不同级别 DOM 的支持情况如下所示： 
DOM2.0 模型将事件处理流程分为三个阶段，即 事件捕获阶段 、 事件处理阶段 、 事件冒泡阶段： 
事件捕获 ：当用户触发点击事件后，顶层对象 document 就会发出一个事件流，从最外层的 DOM 节点向目标元素节点传递，最终到达目标元素。 
事件处理 ：当到达目标元素之后，执行目标元素绑定的处理函数。如果没有绑定监听函数，则不做任何处理。 
事件冒泡 ：事件流从目标元素开始，向最外层 DOM 节点传递，途中如果有节点绑定了事处理函数，这些函数就会被执行。
利用事件冒泡原理可以实现 事件委托 ，所谓事件委托，就是在父元素上添加事件监听器，用以监听和处理子元素的事件，避免重复为子元素绑定相同的事件。当目标元素的事件被触发以后，这个事件就从目标元素开始，向最外层元素传递，最终冒泡到父元素上，父元素 
再通过 event.target获取到这个目标元素，这样做的好处是，父元素只需绑定一个事件监听，就可以对所有子元素的事件进行处理了，从而减少了不必要的事件绑定，对页面性能有一定的提升。
 
14、HTML 解析过程 **** 
浏览器加载 html 文件以后，渲染引擎会从上往下，一步步来解析 HTML 标签，大致过程如下： 
（1）用户输入网址，浏览器向服务器发出请求，服务器返回 html 文件； 
（2）渲染引擎开始解析 html 标签，并将标签转化为 DOM 节点，生成 DOM 树； 
如果 head 标签中引用了外部 css 文件，则发出 css 文件请求，服务器返回该文件，该过程会阻塞后面的解析；如果引用了外部 js 文件，则发出 js 文件请求，服务器返回后立即执行该脚本，这个过程也会阻塞 html 的解析； 
（3）引擎开始解析 body 里面的内容，如果标签里引用了 css 样式，就需要解析刚才下载好的 css 文件，然后用 css 来设置标签的样式属性，并生成渲染树；如果 body 中的 img 标签引用了图片资源，则立即向服务器发出请求，此时引擎不会等待图片下载完毕，而是继续解析后面的标签； 
（4）服务器返回图片文件，由于图片需要占用一定的空间，会影响到后面元素的排版，因此引擎需要重新渲染这部分内容；如果此时 js 脚本中运行了 style.display="none"，布局被改变，引擎也需要重新渲染这部分代码； 
（5）直到 html 结束标签为止，页面解析完毕。
 
15、重绘 和 回流 
当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。比如上面的 img 文件加载完成后就会引起回流，每个页面至少需要一次回流，就是在页面第一次加载的时候。 
当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。 
从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。
 
16、本地存储 
本地存储最原始的方式就是 cookie,cookie 是存放在本地浏览器的一段文本， 数据以键值对的形式保存，可以设置过期时间。 但是 cookie 不适合大量数据的存储，因为每请求一次页面，cookie 都会发送给服务器，这使得 cookie 速度很慢而且效率也不高。因此 cookie 的大小被限制为 4k 左右(不同浏览器可 
能不同,分 HOST)，如下所示： 
Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名(name)、值(value) 和 等号。 
Opera 允许 cookie 多达 4096 个字节，包括：名(name)、值(value) 和 等号。 
Internet Explorer 允许 cookie 多达 4095 个字节，包括：名(name)、值(value) 和 等号。 
在所有浏览器中，任何 cookie 大小超过限制都被忽略，且永远不会被设置。html5 提供了两种在客户端存储数据的新方法：localStorage 和 sessionStorage, 它们都是以 key/value 的形式来存储数据，前者是永久存储，后者的存储期限仅限于浏览器会话 (session)，即当浏览器窗口关闭后，sessionStorage 中的数据被清除。 
localStorage 的存储空间大约 5M 左右，这个相当于一个 5M 大小的前端数据库，相比于 cookie，可以节约带宽，但 localStorage 在浏览器隐私模式下是不可读取的，当存储数据超过了localStorage 的存储空间后会抛出异常。

17、Web 语义化 和 SEO 
Web 语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。 
SEO 是指在了解搜索引擎自然排名机制的基础之上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中关键词的自然排名，获得更多的展现量，吸引更多目标客户点击访问网站，从而达到互联网营销及品牌建设的目标。搜索引擎通过爬虫技术获取的页面就是由一堆 html 标签组成的代码，人可以通过可视化的方式来判断页面上哪些内容是重点，而机器做不到。但搜索引擎会根据标签的含义来判断内容的权重，因此，在合适的位置使用恰当的标签，使整个页面的语义明确，结构清晰，搜索引擎才能正确识别页面中的重要内容，并予以较高的权值。比如 h1~h6 这几个标签在 SEO 中的权值非常高，用它们作页面的标题就是一个简单的 SEO 优化。

18、Canvas绘图，如：Canvas-图形、Canvas-路径、Canvas-文本、Canvas-渐变、Canvas-图像、SVG与Canvas两者间的区别？
SVG是一种使用XML描述2D图形的语言。Canvas通过js来绘制2D图形。SVG基于XML,这意味着SVG DOM中每个元素都是可用的。
在SVG中，每个被绘制的图形均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形。Canvas是逐像素进行渲染的。在Canvas中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需重新绘制，包括任何已被图形覆盖的对象。
19、简述jpg，gif，png-8，png-24的区别，及其各自的使用场景，gif、jpg、png格式的图片在网站制作中的区别
Gif格式特点:
（1）透明性,Gif是一种布尔透明类型，既它可以是全透明，也可以是全不透明，但是它并没有半透明（alpha透明）。
（2）动画,Gif这种格式支持动画。
（3）无损耗性,Gif是一种无损耗的图像格式，这也意味着你可以对gif图片做任何操作也不会使得图像质量产生损耗。
（4）水平扫描,Gif是使用了一种叫作LZW的算法进行压缩的，当压缩gif的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的gif图片比竖向的gif图片更加小。例如50010的图片比10500的图片更加小.
（5）间隔渐进显示,Gif支持可选择性的间隔渐进显示
　　由以上特点看出只有256种颜色的gif图片不适合照片，但它适合对颜色要求不高的图形（比如说图标，图表等），它并不是最优的选择，我们会在后面中看到png是最优的选择。
Jpeg（jpg）格式特点:
（1）透明性,它并不支持透明。
（2）动画,它也不支持动画。
（3）损耗性,除了一些比如说旋转（仅仅是90、180、270度旋转），裁切，从标准类型到先进类型，编辑图片的原数据之外，所有其它操作对jpeg图像的处理都会使得它的质量损失。所以我们在编辑过程一般用png作为过渡格式。
（4）隔行渐进显示,它支持隔行渐进显示（但是ie浏览器并不支持这个属性，但是ie会在整个图像信息完全到达的时候显示）。
　　由上可以看出Jpeg是最适web上面的摄影图片和数字照相机中。
Png格式特点:
（1）类型,Png这种图片格式包括了许多子类，但是在实践中大致可以分为256色的png和全色的png，你完成可以用256色的png代替gif，用全色的png代替jpeg
（2）透明性,Png是完全支持alpha透明的（透明，半透明，不透明）
（3）动画,它不支持动画
（4）PNG图片格式现在包含三种类型：
　　1）PNG8256色PNG的别名
　　2）PNG24全色PNG的别名
　　3）PNG32全色PNG的别名
（5）每个像素上不仅存储了24位真色彩信息还存储了8位的alpha通道信息，就如同GIF能存储透明和不透明信息一样。当我们把图片放到不太搭配的背景上的时候，透明PNG图片的边缘会显示得更加平滑。
对png8的误解
Png8的在ie中的怪异表现：
　（1）半透明的png8在ie6以下的浏览器显示为全透明。
　（2）Alpha透明的全色PNG（png32）在ie6中会出现背景颜色（通常是灰色）。
由上面可以总结：
（a）全透明的png8可以在任一浏览器正常显示（就像gif一样）。半透明的png8在除了ie6及其以下的浏览器下错误的显示成全透明，其它浏览器都能正常显示半透明。这个bug并不需要特殊对待，因为在不支持半透明的浏览器下只是显示为全透明，对用户体验影响不大，它反而是透明gif的加强版。
（b）第二个bug没有什么好的方法解决，只能通过影响性能的方法AlphaImageLoader与需要加特殊标签。
　
19、简述一下你对HTML语义化的理解？
用正确的标签做正确的事情。HTML语义化让页面结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的；搜索引擎的爬虫也依赖于html标记俩确定上下文和各个关键字的权重，利于SEO；使阅读源代码的人对网站更容易将网站分块，便于阅读维护和理解

CSS
1、CSS 选择器 
CSS 选择器即通过某种规则来匹配相应的标签，并为其设置 CSS 样式，常用的有：
1）id 选择器（#myid）
2）类选择器（.myclassname）
3）标签选择器（div，h1，p）
4）相邻选择器（h1 + p）
5）子选择器（ul > li）
6）后代选择器（li a）
7）通配符选择器（* ）
8）属性选择器（ a[rel = "external"]）
9）伪类选择器（a: hover, li: nth - child）
2、CSS Reset 
HTML 标签在不设置任何样式的情况下，也会有一个默认的 CSS 样式，而不同内核浏览器对于这个默认值的设置则不尽相同，这样可能会导致同一套代码在不同浏览器上的显示效果不一致，而出现兼容性问题。因此，在初始化时，需要对常用标签的样式进行初始化，使其默认样式统一，这就是 CSS Reset ，即 CSS 样式重置。

3、为什么要初始化 CSS 样式
因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。然，初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法是：*{padding:0;margin:0} (不建议)

4、盒子布局 
盒子模型是 CSS 布局的基石。常见的盒子模型有块级盒子(block)和行内盒子(inline-block)，与盒子相关的几个属性有：margin、border、padding 和 content等，这些属性的作用是设置盒子与盒子之间的关系以及盒子与内容之间的关系。其中，只有普通文档流中块级盒子的垂直外边距才会发生合并，而行内盒 
子、浮动盒子或绝对定位之间的外边距不会合并。另外，box-sizing 属性的设置会影响盒子 width 和 height 的计算。 

5、浮动布局 
设置元素的 float 属性值为 left 或 right，就能使该元素脱离普通文档流，向左或向右浮动。一般在做宫格布局时会用到，如果子元素全部设置为浮动，则父元素是塌陷的，这时就需要清除浮动，清除浮动的方法也很多，常用的方法是在元素末尾加空元素设置 clear:both，更高级一点的就给父容器设置 before/after 来模拟一个空元素，还可以直接设 置 overflow 属性为 auto/hidden 来清除浮动。除浮动可以实现宫格布局，行内盒子(inline-block)和 table 也可以实现同样的效果。
 
6、定位布局 
设置元素的 position 属性值为 relative/absolute/fixed，就可以使该元素脱离文档流，并以某种参照坐标进行偏移。
releave 是相对定位，它以自己原来的位置进行偏移，偏移后，原来的空间不会被其他 元素占用；	absolute 是绝对定位，它以离自己最近的定位父容器作为参照进行偏移；为了对某个元 素进行定位，常用的方式就是设置父容器的 poistion:relative，因为相对定位元素在不设置top 和 left 值时，不会对元素位置产生影响；
fixed 即固定定位，它则以浏览器窗口为参照物，PC 网页底部悬停的 banner 一般都可以通过 fixed 定位来实现，但 fixed 属性在移动端有兼容性问题，因此不推荐使用，可替代的方案是：绝对定位+内部滚动。
 
7、弹性布局 
弹性布局即 Flex 布局，定义了 flex 的容器一个可伸缩容器，首先容器本身会 根据容器中的元素动态设置自身大小；然后当 Flex 容器被应用一个大小时（width 和 height），将会自动调整容器中的元素适应新大小。Flex 容器也可以设置伸缩比例和固定宽度，还可以设置容器中元素的排列方向（横向和纵 
向）和是否支持元素的自动换行。有了这个神器，做页面布局的可以方便很多了。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。
弹性布局的主要思想是让容器有能力改变项目的宽度盒高度，以填满可用空间(主要是为了容纳所有类型的显示设备和屏幕尺寸)的能力。也就是说：Flex布局使得子项目能够“弹性”的改变其高度，自由填充容器容器剩余空间，以适应容器变大，或者压缩子项目自身，以适应容器变小；同时还可以方便的调节子项目方向和顺序。Flex常用于高度需要自适应，或子项目大小成比例，或水平垂直对齐等场景。
8、各种布局
静态布局：给页面元素设置固定的宽度和高度，单位用px，当窗口缩小，会出现滚动条，拉动滚动条显示被遮挡内容。针对不同分辨率的手机端，分别写不同的样式文件。
　　自适应布局：创建多个静态布局，每个静态布局对应一个屏幕分辨率范围，使用@media媒体查询技术。
　　流式布局：元素的宽高用百分比做单位，元素宽高按屏幕分辨率调整，布局不发生变化。屏幕尺度跨度过大的情况下，页面不能正常显示。
　　响应式布局：采用自适应布局和流式布局的综合方式，为不同屏幕分辨率范围创建流式布局。
弹性布局：要点在于使用em和rem单位来定义元素宽度，与流式布局有极大的相似性，但也有不同之处，主要区别在于弹性布局的尺寸主要根据字体大小而变化。

9、CSS3 动画 
CSS3 中规范引入了两种动画，分别是 transition 和 animation.
transition 可以让元素的 CSS 属性值的变化在一段时间内平滑的过渡，形成动画效果，为了使元素的变换更加丰富多彩，CSS3 还引入transfrom 属性，它可以通过对元素进行 平移(translate)、旋转(rotate)、放大缩小(scale)、倾斜(skew)等操作，来实现 2D 和 3D 变换效果。transiton 还有一个结束事件transitionEnd，该事件是在 CSS 完成过渡后触发，如果过渡在完成之前被移除，则不会触发 transitionEnd 。 
animation 需要设置一个@keyframes，来定义元素以哪种形式进行变换，然后再通过动画函数让这种变换平滑的进行，从而达到动画效果，动画可以被设置为永久循环演示。设置 animation-play-state:paused 
可以暂停动画，设置 animation-fill-mode:forwards可以让动画完成后定格在最后一帧。另外，还可以通过 JS 监听 animation 的开始、结束和重复播放时的状态，分别对应三个事件，即animationStart、animationEnd、animationIteration 。注意，当播放次数设置为 1 时，不会触发animationIteration 。 
和 transition 相比，animation 设置动画效果更灵活更丰富，还有一个区别是：transition只能通过主动改变元素的 css 值才能触发动画效果，而 animation 一旦被应用，就开始执行动画。另外，HTML5 还新增了一个动画 API，即 requestAnimationFrame，它通过 JS 来调用，并按照屏幕的绘制频率来改变 
元素的 CSS 属性，从而达到动画效果。 

10、BFC 
BFC 是格式化上下文，与外界元素互不影响，是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素。比如：内部滚动就是一个 BFC，当一个父容器的 overflow-y 设置为 auto 时，并且子容器的长度大于父容器时，就会出现内部滚动，无论内部的元素怎么滚动，都不会影响父容器以外的布局，这个父容器的渲染区域就叫 BFC。满 
足下列条件之一就可触发 BFC： 
（1）根元素，即 HTML 元素 
（2）float 的值不为 none 
（3）overflow 的值不为 visible 
（4）display 的值为 inline-block、table-cell、table-caption 
（5）position 的值为 absolute 或 fixed 

11、Sprite，Iconfont，@font-face 
对于大型站点，为了减少 http 请求的次数，一般会将常用的小图标排到一个大 图中，页面加载时只需请求一次网络，然后在 css 中通过设置 background-position 来控制显示所需要的小图标，这就是 Sprite 图。 
Iconfont，即字体图标，就是将常用的图标转化为字体资源存在文件中，通过在CSS中引用该字体件，然后可以直接用控制字体的 css 属性来设置图标的样式字体图标的好处是节省网络请求、其大小不受屏幕分辨率的影响，并且可以任意修改图标的颜色。
@font-face 是 CSS3 中的一个模块，通过@font-face 可以定义一种全新的字体，然后就可以通过 css 属性 font-family 来使用这个字体了，即使操作系统没有安装这种字体，网页上也会正常显示出来。 

12、div+css布局较table布局有什么优点？
（1）精简代码
网站使用div+css布局使代码很是精简，css文件可以在网站的任意一个页面进行调用，而若使用table表格修改部分页面却是显得很麻烦。
（2）提高浏览器的访问速度
（3）浏览器兼容性
Div+css相比table布局，更容易出现多种浏览器不兼容的问题，主要原因是各种浏览器对web的默认值不同。

13、CSS可以继承的属性有：font-size,font-family,color
不可以继承的属性有：border padding margin width height
可继承的样式： font-size font-family color, UL LI DL DD DT
不可继承的样式：border padding margin width height
优先级就近原则，同权重情况下样式定义最近者为准载入样式以最后载入的定位为准;优先级为: !important > id > class > tag ； important 比 内联优先级高


14、css引入的方式有哪些？link和@import的区别是？
（1）内联方式，直接在html标签中的style属性中添加css
（2）嵌入方式,在html头部中的<style>标签下书写css代码
（3）链接方式，在html的头部的<head>标签中引入外部的css
（4）导入方式,导入方式指的是使用CSS规则引入外部css文件

15、px和em的区别
px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。
em得值不是固定的，并且em会继承父级元素的字体大小。
    rem是CSS3新增的一个相对单位，可以理解为"root em"，相对于根节点html的字体大小来计算的，chrome/firefox/IE9+支持。任意浏览器的默认字体高都是16px，所以未经调整的浏览器都符合: 1rem=16px。
16、css3有哪些新特性？
1）CSS3 实现圆角（border-radius:8px;），
2）阴影（box-shadow:10px）,
3）对文字加特效（text-shadow）,
4）线性渐变（gradient），
5）旋转（transform）,
6）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转，缩放，定位，倾斜 ,
7）增加了更多的 css 选择器 ,
8）多背景 rgba ,
17、IE浏览器css浮动与兼容性问题
浮动之后，需要清除浮动才不会产生问题。现在主流方法是在浮动元素的父级添加一个class，然后父级添加一个class=“clear”即可。

18、垂直水平居中的方法
（1）绝对定位：top:50%; left:50%; margin-left: -width/2; margin-top: -height/2;
（2）绝对定位：left:50%; top:50%; transform:translateX(-50%) translateY(-50%);
（3）flex布局：父元素：display:left; justify-content:center; align-items:center;
（4）Table-cell：父元素：display:table-cell; text-align:center; vertical-align:middle
（5）绝对定位：margin:auto; top:0; bottom:0; left:0; right:0;
20、页面导入样式时，使用link和@import有什么区别？
（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS，定义rel连接属性等作用；而@import是css提供的，只能用于加载css
（2）页面加载时，link会同时被加载，而@import引用的css会等到页面加载完成再加载；
（3）Import是css2.1提出的，只在IE4以上才能被识别，而link是XHTML标签，无兼容问题。
（4）Link支持使用JS控制DOM去改变样式，而@import不支持。

JS
1、基础语法 
Javascript 基础语法包括：变量声明、数据类型、函数、控制语句、内置对象等。
在 ES5 中，变量声明有两种方式，分别是 var 和 function ，var 用于声明普通的变量，接收任意类型，function 用于声明函数。另外，ES6 新增了 let、const、import 和 class 等四个命令，分别用以声明普通变量、静态变量、模块和类 。 
JS 数据类型共有六种，分别是 String、Number、Boolean、Null、Undefined 和 Object 等， 另外，ES6 新增了Symbol 类型。其中，Object 是引用类型，其他的都是原始类型(PrimitiveType)。 
原始类型也称为基本类型或简单类型，因为其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈(stack)中(按值访问)。为了便于操作这类数据，ECMAScript提供了 3 个基本包装类型 ：Boolean、Number 和 String。基本包装类型是一种特殊的引用类型，每当读取一个基本类型值的时候，JS内部就会创建一个对应的包装对象从而可以调用一些方法来操作这些数据。 
引用类型由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此其存储在堆(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)，对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法；但基本类型不可以添加属性和方法。 
Javascript 可以通过 typeof 来判断原始数据类型，但不能判断引用类型，要知道引用类型的具体类型，需要通过 Object 原型上的toString 方法来判断。JS 中的函数存在着三种角色：普通函数、构造函数、对象方法。同一个函数，调用方式不同，函数的作用不一样，所扮演的角色也不一样。直接调用时就是普通函数，通过 new 创建对象时就是构造函数，通过对象调用时就是方法。 
JS 常用的内置对象有 window、Date、Array、JSON、RegExp等，window 是浏览器在执行脚本时创建的一个全局对象，主要描述浏览器窗口相关的属性和状态，这个后面会讲到，Date 和 Array使用场景最多，JSON 主要用于对象的序列化和反序列化，还有一个作用就是实现对象的深拷贝。RegExp 即正则表达式，是处理字符串的利器。 

2、函数原型链 
JS 是一种基于对象的语言，但在 ES6 之前是不支持继承的，为了具备继承的 
能力，Javascript 在函数对象上建立了原型对象 prototype，并以函数对象为主线，从上至下，在 JS 内部构建了一条 原型链 。
原型链把一个个独立的对象联系在一起，Object则是所有对象的祖宗， 任何对象所建立的原型链最终都指向了 Object，并以 Object 终结。
简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本 
身是否存在，如果不存在就去该对象所在的原型连上去找，直到 Object 对象为 
止，如果都没有找到该属性才会返回 undefined。因此，我们可以通过原型链 
来实现 JS 继承。 

3、函数作用域 
函数作用域就是变量在声明它们的函数体以及这个函数体嵌套的任意函数体内 都是有定义的。因此， JS 中没有块级作用域只有函数作用域 ，这种设计导致 JS 中出现了 变量提升 的问题。简单来说就是，将变量声明提升到它所在作用域的最开始的部分，为了解决变量提升带来的副作用，ES6 新增了let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题。 

4、this 指针 
this 指针存在于函数中，用以标识函数运行时所处的上下文。函数的类型不同，this 指向规则也不一样：对于普通函数，this 始终指向全局对象 window；对于构造函数，this 则指向新创建的对象；对于 
方法，this 指向调用该方法的对象。另外，Function 对象也提供了 call、apply 和 bind 等方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind 一般在事件回调中使用，而 call 和 apply 
的区别只是参数的传递方式不同。如果往深的去理解，无论什么函数，this 是否被改变， 本质上，this 均指向触 发函数运行时的那个对象。而在函数运行时，this 的值是不能被改变的。 

5、new 操作符 
函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()。JS 中的函数即可以是函数，也可以是方法，还可以是构造函数。 当使用 new 来创建对象时，该函数就是构造函数，JS 将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型 prototype 中的方法和属性。 

5、闭包 
闭包是指有权访问一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。闭包是一个具有独立作用域的静态执行环境。和函数作用域不同的是，闭包的作用域是静态的，可以永久保存局部资源，而函数作用域只存在于运行时，函数执行结束后立即销毁。因此，闭包可以形成一个独立的执行过程，
闭包的特性是在函数内部再嵌套函数，内部函数可以引用外层的参数和变量
闭包有三个特性：
（1）函数嵌套函数
（2）函数内部可以引用外部的参数和变量
（3）参数和变量不会被垃圾回收机制回收
闭包常见用途：
（1）创建特权方法用于访问控制
（2）事件处理程序及回调
使用闭包的注意点
1）滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2）会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

6、单线程和异步队列 
Javascript 是单线程语言，在浏览器中，当 JS 代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境在栈中采用后进先出(LIFO)的顺序来执行代码块，以保证所有的函数能按照正确的顺序被执行。 
但在浏览器中，有一些任务是非常耗时的，比如 ajax 请求、定时器、事件等，为了保证非耗时任务不受影响，Javascript 在执行环境中维护了一个异步队列(也叫工作线程)，并将这些耗时任务放入队列 
中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，主线程才会去检查异步队列中的任务是否需要开始执行。 
JS 中的 setTimeout 和 setInterval 就是典型的异步操作，它们会被放入异步 
队列中等待，即使 setTimeout(0)也不会被立即执行，需要等到当前同步任务结束后才会被执行。
 
7、异步通信 Ajax 技术 
Ajax 是浏览器专门用来和服务器进行交互的异步通讯技术，其核心对象是XMLHttpRequest，通过该对象可以创建一个 Ajax 请求。Ajax 请求是一个耗时的异步操作，当请求发出以后，Ajax 提供了两个状态位来描述请求在不同阶段的状态，这两个状态位分别是 readyState 和 status ，readyState 通过5 个状态码来描述一个请求的 5 个阶段： 
0 - 请求未发送，初始化阶段 
1 - 请求发送中，服务器还未收到请求 
2 - 请求发送成功，服务器已收到请求 
3 - 服务器处理完成，开始响应请求，传输数据4 - 客户端收到请求，并完成了数据下载，生成了响应象 	status 用于描述服务端对请求处理的情况，200 表示正确响应了请求，404表示服务器找不到资源，500 代表服务器内部异常等等。 
Ajax 对象还可以设置一个 timeout 值，代表超时时间，切记：timeout 只会影响readyState，而不会影响 status，因为超时只会中断数据传输，但不会影响服 务器的处理结果。
status 是 200，但 response 里却没有数据，这种情况就是服务器正确响应了请求，但数据的下载被超时中断了。为了防止 XSS 攻击，浏览器对 Ajax 请求做了限制，不允许 Ajax 跨域请求服务器，只允许请求和当前地址同域的服务器资源。但不限制脚本和标签发送跨域请求，比如script 和 img 标签，因此可以利用脚本跨域能力来实现跨域请求，即 JSONP的原理。 
JSONP 虽然可以解决跨域问题，但只能是 get 请求，并且没有有效的错误捕获机制，为了解决这个问题，XMLHttpRequest Level2 提出了CORS 模型，即 跨域资源共享， 它不是一个新的 API，而是一个标准规范，当浏览器发现该请求需要跨域时，就会自动在头信息中添加一个 Origin字段，用以说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。随着移动端的快速发展，Web 技术的应用场景正在变得越来越复杂， 关注点分离 原则在系统设计层面就显得越来越重要，而 XMLHttpRequest 是 
Ajax 最古老的一个接口，因而不太符合现代化的系统设计理念。因此，浏览器提供了一个新的 Ajax 接口，即 Fetch API ，Fetch API 是基于 Promise 思想设计的，更符合关注点分离原则。 

8、模块化 
在 ES6 之前，为了实现 JS 模块化编程，社区制定了一些模块加载方案，最主要有CMD 和 AMD 两种，分别以 commonjs 和 requirejs 为代表。ES6 在语言标准的层面上，实现了模块化编程，其设计思想是，尽量静态化，使得编译时就能确定模块的依赖关系，即编译时加载，而 CMD 和 AMD 是在运行时确定依赖关系，即运行时加载。 

9、ES6熟悉吗，说几个ES6的新增方法
ES6 是 ECMAScript 6.0 的简写，即 Javascript 语言的下一代标准，它的目标是让 JS 能够方便的开发企业级大型应用程序，ES6 规范中，比较重大的变化有以下几个方面： 
（1）新增 let、const 命令。 let用来声明变量，const用来声明常量，let和const都是块级作用域，和 var 相比，let 声明的变量不存在变量提升问题，但没有改变 JS 弱类型的特点，依然可以接受 任意类型变量的声明；const 声明的变量不允许在后续逻辑中改变，提高了 JS 语法的严谨性。 
（2）新增解构赋值、rest 语法、箭头函数，这些都是为了让代码看起来更简洁，而 包装的语法糖。 
（3）新增模块化，这是 JS 走向规范比较重要的一步，让前端更方便的实现工程化。
ES6标准中，JavaScript原生支持模块(module)了。这种将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口。import用于在一个模块中加载另一个含有export接口的模块。import和export命令只能在模块的顶部，不能在代码块之中。 
（4）新增类和继承的概念，配合模块化，JS 也可以实现高复用、高扩展的系统架构。 
（5）新增模板字符串功能，高效简洁，结束拼接字符串的时代。 
（6）新增 Promise 对象，解决异步回调多层嵌套的问题。 
（7）ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。
（8）新增箭头函数。写法：函数名=(形参)=>{……}    当函数体中只有一个表达式时，{}和return可以省略，当函数体中形参只有一个时，()可以省略。特点：箭头函数中的this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window。
（9）新增for...of  循环它是遍历所有数据结构的统一的方法。for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串.
10、说出至少5个ES6的新特性，并简述它们的作用。（简答题）
（1）let关键字，用于声明只在块级作用域起作用的变量；const关键字，用于声明一个常量；
（2）结构赋值，一种新的变量赋值方式。常用于交换变量值，提取函数返回值，设置默认值；
（3）Symbol数据类型，定义一个独一无二的值；
（4）Proxy代理，用于编写处理函数，来拦截目标对象的操作；
（5）for...of遍历，可遍历具有iterator接口的数据结构；
（6）Set结构，存储不重复的成员值的集合；
（7）Map结构，键名可以是任何类型的键值对集合；
（8）Promise对象，更合理、规范地处理异步操作；
（9）Class类定义类和更简便地实现类的继承；

11、Set 怎么去重
ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数，如：
let array = [1, 1, 1, 1, 2, 3, 4, 4, 5, 3];
let set = new Set(array);
console.log(set); // 此时打印的是set 结构 Set(5) {1, 2, 3, 4, 5}

12、promise 实现原理? promise的三种状态 
Promise是异步编程的一种解决方案，实际上解决jquery的ajax回调地域(解决层层嵌套),将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。
Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。then()方法接收两个参数：onResolve和onReject，分别代表当前 promise 对象在成功或失败时。	promise两个特点:
（1）对象的状态不受外界影响
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。
promise 缺点: 无法取消promise,如果不设置回调函数,promise内部抛出错误，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

13、es6继承和es5继承的区别

14、箭头函数和普通函数的区别
两者最关键的区别就是this指向的区别，普通函数中的this指向函数被调用的对象，因此不同的调用者，this的值是不同的。而箭头函数中并没有自己的this，箭头函数中this是固定的，它指向定义该函数时所在的对象。
箭头函数：
let fun = () => {
console.log('lalalala');
}
普通函数：
function fun() {
    console.log('lalla');
}
箭头函数相当于匿名函数，并且简化看函数的定义。箭头函数有两种格式，一种只包含一个表达式，连{...}和return都省略掉了。还有一种可以包含多条语句，在这时候不能省略{...}和return
箭头函数是匿名函数，不能作为构造函数，不能使用new，箭头函数不能绑定arguments，取而代之用rest参数解决。
箭头函数不绑定this,会捕获其在的上下文的this的值，作为自己的this值。
箭头函数通过call()或apply()方法调用一个函数时，只传入了一个参数，对this并没有影响。

15、对async 和 await的认识

16、进程和线程的区别
进程是具有独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
线程是进行的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。
一个线程可以创建和撤销另一个线程；同一个线程中的多个线程之间可以并发执行。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
简而言之，一个程序至少有一个进程，一个进程至少有一个线程。

17、js是单线程还是多线程？
Js的单线程与它的用途有关，作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。

18、js既然是单线程，怎么实现异步？
JS实现异步编程有四种方法，第一种是回调函数，采用这种方式，把同步操作变成了异步操作，回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护。第二种是事件监听，任务的执行不取决于代码的顺序，而取决于每个事件是否发生。这种方法的优点是比较任意理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去耦合，实现模块化。第三种发布/订阅，假定存在一个信号中心，某个任务完成就向信号中心发布一个信号，其他任务可以向信号中心订阅这个信号，从而找到自己什么时候开始执行。第四种promise对象，它的思想是每个异步任务返回一个promise对象，该对象有一个then方法，允许指定回调函数。

19、浏览器的内核分别是什么?
IE: trident内核
Firefox：gecko内核
Safari：webkit内核
Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核
Chrome：Blink(基于webkit，Google与Opera Software共同开发)

20、cookies，sessionStorage和localStorage的区别？
共同点：都是保存在浏览器端，且是同源的。
区别：cookies是为了标识用户身份而存储在用户本地终端上的数据，始终在同源http请求中携带，即cookies在浏览器和服务器间来回传递，而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。
存储大小的限制不同。cookie保存的数据很小，不能超过4k，而sessionstorage和localstorage保存的数据大，可达到5M。
数据的有效期不同。cookie在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。sessionstorage仅在浏览器窗口关闭之前有效。localstorage始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。
作用域不同。cookie在所有的同源窗口都是共享；sessionstorage不在不同的浏览器共享，即使同一页面；localstorage在所有同源窗口都是共享。

21、iframe框架有那些优缺点？
优点：
（1）iframe能够原封不动的把嵌入的网页展现出来。
（2）如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
（3）网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
（4）如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。
缺点：
搜索引擎的爬虫程序无法解读这种页面框架结构中出现各种滚动条使用框架结构时，保证设置正确的导航链接。iframe页面会增加服务器的http请求。

22、如何实现浏览器内多个标签页之间的通信?
WebSocket SharedWorker
也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。
注意：Safari 在无痕模式下设置 localstorge 值时会抛出QuotaExceededError 的异常

23、webSocket如何兼容低浏览器？
Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR引用WebSocket.js这个文件来兼容低版本浏览器。

24、网页验证码是干嘛的，是为了解决什么安全问题？
区分用户是计算机还是人的程序;可以防止恶意破解密码、刷票、论坛灌水；

25、title与h1的区别、b与strong的区别、i与em的区别？
title属性没有明确意义，只表示标题；h1表示层次明确的标题，对页面信息的抓取也有很大的影响。
strong标明重点内容，语气加强含义；b是无意义的视觉表示
em表示强调文本；i是斜体，是无意义的视觉表示
视觉样式标签：b i u s
语义样式标签：strong em ins del code

26、元素的alt和title有什么异同？
在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。

27、优化图片加载的方法
（1）懒加载；（2）在页面载入的时候将页面上的img标签的src指向一个小图片，把真实地址存放在一个自定义属性中。如果图片为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张下载。（3）如果图片为css图片，可以使用cssSprite,SVGsprite,Iconfont,Base64等技术。
（4）如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。（5）如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。

28、Js面向对象的几种方式
（1）对象的字面量 var obj = {}
（2）创建实例对象 var obj = new Object();
（3）构造函数模式 function fn(){} , new fn();
（4）工厂模式：用一个函数，通过传递参数返回对象。function fn(params){var obj =new Object();obj.params = params; return obj;},fn(params);
（5）原型模式：function clock(hour){} fn.prototype.hour = 0; new clock();
首先，每个函数都有一个prototype(原型)属性，这个指针指向的就是clock.prototype对象。而这个原型对象在默认的时候有一个属性constructor，指向clock，这个属性可读可写。而当我们在实例化一个对象的时候，实例newClock除了具有构造函数定义的属性和方法外（注意，只是构造函数中的）,还有一个指向构造函数的原型的指针，ECMAScript管他叫[[prototype]]，这样实例化对象的时候，原型对象的方法并没有在某个具体的实例中，因为原型没有被实例。

29、JQuery中有几种类型的选择器
（1）层叠选择器$(“form input”)
（2）基本过滤选择器 :first :last :not()
（3）内容过滤选择器:odd:eq():animated
（4）可视化过滤选择器 :hidden :visible
（5）属性过滤选择器：div[id]
（6）子元素过滤选择器:first一child :last一child :only :child
（7）表单元素过滤选择器 :enabled :disabled :checked :selected
（8）id,类，类型,元素…

30、Ajax同步和异步的区别，如何解决跨域问题
同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.
同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。
异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。

31、js放在html的不同位置有什么区别吗？
如果使用window.onload函数，将js代码放在其中，则放在哪里都是一样的，因为都是在body加载完再执行的，如果不使用window.onload函数,放在head中的话，代码不会被执行，这是因为html执行顺序，确切的说是js的执行顺序，HTML从上运行到 的时候进入test.js文件。前面的不会运行，也就是被function包起来的不会被运行，这个时候就执行最后一句。去页面中取元素。但是这个时候，HTML页面并没有加载完。所以找不到元素，就会报错。

32、ajax和jsonp的区别是？
实现方法完全不一样。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加。

33、content-type是什么？有什么作用？
Content-Type是显示字符集的设定一般在meta信息中，这个功能就是通过读取HTML页面META标签 的Content-Type属性而得知需要使用哪种字符集显示该页面的。

34、block, inline-block, inline三者之前有什么区别？
Block独占一行，可以设置宽高，自动填满父元素高度，可以设置margin和padding
ineLine-block与其他元素占一行，可以设置宽高，，可以设置margin和padding
inline不会独占一行，不可以设置宽高，可以设置margin padding。

35、Object.js()与原来的比较操作符“===”、“==”的区别
两等号判等，会在比较时进行类型转换。
三等号判等比较严格，比较时不进行隐形类型转换，类型不同会返回false。
Object.js()在三等号判等的基础上特别处理了NAN，-0，+0，保证-0和+0不再相同，当Object.js(NAN,NAN)会返回true。
Object.js应该被认为有特殊的用途，二不能用它认为比其他更宽松或严格。

36、变量的作用域
变量的作用域分类：全局变量和局部变量。
特点：
（1）函数内部可以读取函数外部的全局变量；在函数外部无法读取函数内的局部变量。
（2）函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

37、什么是跨域？跨域请求资源的方法有哪些？
由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域
跨域请求资源的方法：(1)porxy代理；(2)CORS 【Cross-Origin Resource Sharing】；(3) jsonp

38、比较typeof与instanceof？
相同点：js中typeof与instanceof常用来判断一个变量是否为空，或者是什么类型的。
Typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。
细节：
（1）typeof一般只能返回如下几个结果：number、boolean、string、function、object、undefined
（2）typeof来获取一个变量是否存在，如if(typeof a!=“undefined”){alert(“ok”)},而不要去使用if(a)因为如果a不存在（未声明）则会出错。
（3）对于Array,Null等特殊对象使用typeof一律返回object，这正是typeof的局限性。
Instanceof定义和用法：instanceof用于判断一个变量是否属于某个对象的实例。

39、Ajax的优缺点及工作原理？
定义和用法:
AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 是一种用于创建快速动态网页的技术。Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。
传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。
优点：
（1）减轻服务器的负担,按需取数据,最大程度的减少冗余请求
（2）局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验
（3）基于xml标准化,并被广泛支持,不需安装插件等,进一步促进页面和数据的分离
缺点：
（1）AJAX大量的使用了javascript和ajax引擎,这些取决于浏览器的支持.在编写的时候考虑对浏览器的兼容性.
（2）AJAX只是局部刷新,所以页面的后退按钮是没有用的.
（3）对流媒体还有移动设备的支持不是太好等
AJAX的工作原理：
（1）创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）
（2）判断数据传输方式(GET/POST)
（3）打开链接 open()
（4）发送 send()
（5）当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数

40、请指出document load和document ready的区别？
共同点：这两种事件都代表的是页面文档加载时触发。
异同点：
ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。
onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。

jquery
1、jQuery 库中的 $() 是什么？
$() 函数是 jQuery() 函数的别称。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。

2、如何找到所有 HTML select 标签的选中项？
$('[name=selectname] :selected')

3、$(this) 和 this 关键字在 jQuery 中有何不同？
$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。
而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。

4、jquery怎么移除标签onclick属性？
获得a标签的onclick属性: $("a").attr("onclick")
删除onclick属性：$("a").removeAttr("onclick");
设置onclick属性：$("a").attr("onclick","test();");

5、jquery中addClass,removeClass,toggleClass的使用。
$(selector).addClass(class)：为每个匹配的元素添加指定的类名
$(selector).removeClass(class)：从所有匹配的元素中删除全部或者指定的类，删除class中某个值；
$(selector).toggleClass(class)：如果存在（不存在）就删除（添加）一个类
$(selector).removeAttr(class);删除class这个属性；

6、JQuery有几种选择器?
(1)、基本选择器：#id，class,element,*;
(2)、层次选择器：parent > child，prev + next ，prev ~ siblings
(3)、基本过滤器选择器：:first，:last ，:not ，:even ，:odd ，:eq ，:gt ，:lt
(4)、内容过滤器选择器： :contains ，:empty ，:has ，:parent
(5)、可见性过滤器选择器：:hidden ，:visible
(6)、属性过滤器选择器：[attribute] ，[attribute=value] ，[attribute!=value] ，[attribute^=value] ，[attribute$=value] ，[attribute*=value]
(7)、子元素过滤器选择器：:nth-child ，:first-child ，:last-child ，:only-child
(8)、表单选择器： :input ，:text ，:password ，:radio ，:checkbox ，:submit 等；
(9)、表单过滤器选择器：:enabled ，:disabled ，:checked ，:selected

7、jQuery中的Delegate()函数有什么作用？
   delegate()会在以下两个情况下使用到：
 （1）、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：
$("ul").delegate("li", "click", function(){ $(this).hide(); });
（2）、当元素在当前页面中不可用时，可以使用delegate()

8、$(document).ready()方法和window.onload有什么区别？
 (1)、window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。
 (2)、$(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。

10、 jquery中$.get()提交和$.post()提交有区别吗？
相同点：都是异步请求的方式来获取服务端的数据；
异同点：
（1）、请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。
（2）、参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。
（3）、数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多
（4）、安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。

11、jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？
(1)、bind 【jQuery 1.3之前】
定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；
语法：bind(type,[data],function(eventObject))；
特点：
　　(1)、适用于页面元素静态绑定。只能给调用它的时候已经存在的元素绑定事件，不能给未来新增的元素绑定事件。
　　(2)、当页面加载完的时候，你才可以进行bind()，所以可能产生效率问题。
实例如下：$( "#members li a" ).bind( "click", function( e ) {} );
(2)、live 【jQuery 1.3之后】
定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；
语法：live(type, [data], fn);
特点：
　　(1)、live方法并没有将监听器绑定到自己(this)身上，而是绑定到了this.context上了。
　　(2)、live正是利用了事件委托机制来完成事件的监听处理，把节点的处理委托给了document，新添加的元素不必再绑定一次监听器。
　　(3)、使用live（）方法但却只能放在直接选择的元素后面，不能在层级比较深，连缀的DOM遍历方法后面使用，即$(“ul”").live...可以，但$("body").find("ul").live...不行； 
实例如下：$( document ).on( "click", "#members li a", function( e ) {} );
(3)、delegate 【jQuery 1.4.2中引入】
定义和用法：将监听事件绑定在就近的父级元素上
语法：delegate(selector,type,[data],fn)
特点：
　　(1)、选择就近的父级元素，因为事件可以更快的冒泡上去，能够在第一时间进行处理。
　　(2)、更精确的小范围使用事件代理，性能优于.live()。可以用在动态添加的元素上。
实例如下：
$("#info_table").delegate("td","click",function(){/*显示更多信息*/});
$("table").find("#info").delegate("td","click",function(){/*显示更多信息*/});
(4)、on 【1.7版本整合了之前的三种方式的新事件绑定机制】
定义和用法：将监听事件绑定到指定元素上。
语法：on(type,[selector],[data],fn)
实例如下：$("#info_table").on("click","td",function(){/*显示更多信息*/});参数的位置写法与delegate不一样。
说明：on方法是当前JQuery推荐使用的事件绑定方法，附加只运行一次就删除函数的方法是one()。
 总结：.bind(), .live(), .delegate(),.on()分别对应的相反事件为：.unbind(),.die(), .undelegate(),.off()

VUE

1、v-model原理解析
v-model可以实现双向数据绑定，根据官方文档介绍，v-model本质上就是语法糖，即利用v-model绑定数据后，其实就是既绑定了一个数据，又添加了一个input事件监听。
当在input元素中使用v-model实现双向数据绑定，其实就是在输入的时候触发元素的input事件，通过这个语法糖，也能够实现父子组件数据的双向绑定。

2、什么是MVVM？
MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象（桥梁）。
在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。
ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。
3、mvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？
mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。
区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多的场景，更加便捷
4、vue的优点是什么？
（1）低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。
（2）可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。
（3）独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。
（4）可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。

5、组件之间的传值？
（1）父组件与子组件传值
	父组件通过标签上面定义传值：eg='data'父组件中 data(){return {data:'egdata'}}
子组件通过props方法接受数据 props:['eg'] 在props 中添加了元素之后，就不需要在 data 中再添加变量了。
（2）子组件向父组件传递数据
	子组件通过$emit方法传递参数。
（3）子组件向子组件传递数据
Vue 没有直接子对子传参的方法，建议将需要传递数据的子组件，都合并为一个组件。如果一定需要子对子传参，可以先从传到父组件，再传到子组件。
为了便于开发，Vue 推出了一个状态管理工具 Vuex，可以很方便实现组件之间的参数传递。

6、路由之间跳转
声明式（标签跳转）、编程式（js跳转）
①直接修改地址栏中的路由地址 ②通过router-link实现跳转

7、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？
第一步：在components目录新建你的组件文件（如：indexPage.vue），script一定要export default {}
第二步：在需要用的页面（组件）中导入：import indexPage from '@/components/indexPage.vue'
第三步：注入到vue的子组件的components属性上面,components:{indexPage}
第四步：在template视图view中使用，例如有indexPage命名，使用的时候则index-page

8、vuex是什么？怎么使用？哪种功能场景使用它？
vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车。

9、vuex有哪几种属性？
有五种，分别是State、Getter、Mutation 、Action、Module
（1）vuex的State特性
①Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data
②state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
③它通过mapState把全局state 和getters 映射到当前组件的computed 计算属性中
（2）vuex的Getter特性
①getters 可以对State进行计算操作，它就是Store的计算属性
②虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用
③如果一个状态只在一个组件内使用，是可以不用getters
（3）vuex的Mutation特性
	Action 类似于mutation，不同在于：Action 提交的是mutation，而不是直接变更状态；Action 可以包含任意异步操作。

10、不用Vuex会带来什么问题？
（1）可维护性会下降，想修改数据要维护三个地方；
（2）可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；
（3）增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。

11、v-show和v-if指令的共同点和不同点
（1）v-show指令是通过修改元素的display的CSS属性让其显示或者隐藏
（2）v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果

12、如何让CSS只在当前组件中起作用
将当前组件的<style>修改为<style scoped>

13、<keep-alive></keep-alive>的作用是什么?
<keep-alive></keep-alive> 包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。

14、指令v-el的作用是什么?
提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例.

15、、请列举出3个Vue中常用的生命周期钩子函数
（1）created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见。
（2）mounted: el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当mounted 被调用时vm.$el 也在文档内。
（3）activated: keep-alive组件激活时调用

16、active-class是哪个组件的属性？
vue-router模块的router-link组件。

17、怎么定义vue-router的动态路由以及如何获取传过来的动态参数？
在router目录下的index.js文件中，对path属性加上/:id。
	使用router对象的params.id。

18、vue-router有哪几种导航钩子？
三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。
第二种：组件内的钩子；
第三种：单独路由独享组件

19、生命周期相关面试题
总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。
·创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。
·载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
·更新前/后：当data变化时，会触发beforeUpdate和updated方法。
·销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在
（1）什么是vue生命周期
Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是Vue 的生命周期。
（2）vue生命周期的作用是什么
它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。
（3）第一次页面加载会触发哪几个钩子
第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子
（4）DOM渲染在哪个周期中就已经完成
DOM 渲染在 mounted 中就已经完成了。
（5）简单描述每个周期具体适合哪些场景
生命周期钩子的一些使用方法：
·beforecreate : 可以在这加个loading事件，在加载实例时触发
·created :初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用
·mounted : 挂载元素，获取到DOM节点
·updated : 如果对数据统一处理，在这里写上相应函数
·beforeDestroy : 可以做一个确认停止事件的确认框
·nextTick : 更新数据后立即操作dom

20、说出至少4种vue当中的指令和它的用法？
v-if：判断是否隐藏；v-for：数据循环；v-bind:class：绑定一个属性；v-model：实现双向绑定

21、vue-loader是什么？使用它的用途有哪些？
解析.vue文件的一个加载器。（深入理解见https://www.jb51.net/article/115480.htm）
用途：js可以写es6、style样式可以scss或less、template可以加jade等
根据官网的定义，vue-loader 是 webpack 的一个 loader，用于处理 .vue 文件。
其次，使用vue-cli脚手架，作者已经配置好了基本的配置，开箱及用，你需要做的就是npm install 安装下依赖，然后就可以开发业务代码了。当然，如果你想进阶，最好熟悉下vue-loader的具体配置，而不要依赖脚手架

22、scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？
答：css的预编译。（scss是sass的一个升级版本，完全兼容sass之前的功能，又有了些新增能力，最主要的就是sass是靠缩进表示嵌套关系，scss是花括号）
使用步骤：
第一步：先装css-loader、node-loader、sass-loader等加载器模块
第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss
第三步：在同一个文件，配置一个module属性
第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”
特性:
·可以用变量，例如（$变量名称=值）；
·可以用混合器，混入@mixin 可以传变量
·可以嵌套
　　　继承@extend不可以传变量，相同样式直接继承，不会造成代码冗余；基类未被继承时，也会被编译成css代码

23、为什么使用key？
当有相同标签名的元素切换时，需要通过key 特性设置唯一的值来标记以让Vue 区分它们，否则Vue 为了效率只会替换相同标签内部的内容。

24、为什么避免v-if和v-for用在一起
当Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算v-for。

25、VNode是什么？虚拟 DOM是什么？ 详情见 https://www.jb51.net/article/105221.htm
Vue在页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟DOM”是由Vue 组件树建立起来的整个VNode 树的称呼。

26、active-class是哪个组件的属性？嵌套路由怎么定义？
vue-router模块的router-link组件。
嵌套路由顾名思义就是路由的多层嵌套。一级路由里面使用children数组配置子路由，就是嵌套路由。

27、mint-ui是什么？怎么使用？说出至少三个组件使用方法？htthttps://www.cnblogs.com/stella1024/p/7771334.html
基于vue的前端组件库。npm安装，然后import样式和js，vue.use（mintUi）全局引入。在单个组件局部引入：import {Toast} from ‘mint-ui’。组件一：Toast(‘登录成功’)；组件二：mint-header；组件三：mint-swiper
 
28、v-model是什么？怎么使用？vue中标签怎么绑定事件？
可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：<input @click=doLog() />
 
29、axios是什么？怎么使用？描述使用它实现登录功能的流程？
答：请求后台资源的模块。npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中
 Vue.js 1.0 我们常使用 vue-resource (官方ajax库), Vue 2.0 发布后作者宣告不再对 vue-resource 进行更新， 推荐我们使用 axios (基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 node.js 中使用)

30、mvvm框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？
一个model+view+viewModel框架，数据模型model，viewModel连接两个区别：vue数据驱动，通过数据来显示视图层而不是节点操作。
场景：数据操作比较多的场景，更加便捷
 
31、自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？
全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives
钩子函数：bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）
钩子函数参数：el、binding

32、vue-router是什么？它有哪些组件？
vue用来写路由一个插件。router-link、router-view
 
33、导航钩子有哪些？它们有哪些参数？
导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave
参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种。
 
34、Vue的双向数据绑定原理是什么？
答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：
第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
①在自身实例化时往属性订阅器(dep)里面添加自己
②自身必须有一个update()方法
③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

35、请说下封装vue组件的过程？
首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。
然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。
 
36、你是怎么认识vuex的？
vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。
通过状态（数据源）集中管理驱动组件的变化（好比spring的IOC容器对bean进行集中管理）。
应用级的状态集中放在store中；改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。

37、请说出vue.cli项目中src目录每个文件夹和文件的用法？
assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件
 
38、vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？
第一步：在components目录新建你的组件文件（smithButton.vue），script一定要export default 
第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’
第三步：注入到vue的子组件的components属性上面,components:{smithButton}
第四步：在template视图view中使用，<smith-button>  </smith-button>
问题有：smithButton命名，使用的时候则smith-button。
 
39、聊聊你对Vue.js的template编译的理解？ https://www.jianshu.com/p/e1669afa30b8 
简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）
详情步骤：
首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 抽象语法树  即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。
然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）
组件的设计原则
(1)页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块) 
(2)每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在vue.js中，通过.vue文件将组件依赖的模板，js，样式写在一个文件中) 
(每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑) 
(3)页面不过是组件的容器，组件可以嵌套自由组合成完整的页面

40、Vue实现数据双向绑定的原理：Object.defineProperty（）
vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。
vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。

41、Vue的路由实现：hash模式 和 history模式
hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；
特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。
hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。
history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。
history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”
42、对keep-alive 的了解？
keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。
参数解释
include - 字符串或正则表达式，只有名称匹配的组件会被缓存
exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存
include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。

43、$route和$router的区别
答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

44、vue.js的两个核心是什么？
数据驱动、组件系统

45、vue常用的修饰符？
	.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用

46、.vue等单页面应用及其优缺点
优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。

47、vue原理间接
vue.js中有两个核心功能：响应式数据绑定，组件系统。
在官方文档中指出，当你把一个普通的js对象传给vue实例的data选项，vue将遍历此对象所有的属性，并使用object.defineProperty把这些属性全部转为getter/setter.
这些getter/setter对用户来说是不可见的，但在内部它们让vue追踪依赖，在属性被访问和修改时通知变化。
每个组件实例都有相应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。
Getter：主要是获取到对应的键值，将原来的getter和setter提取出来
Setter:主要是对相同的值的拦截，然后对于嵌套对象的重新observe，这里之所以会重新observe是因为在每次响应了数据变化后，会清除所有的依赖，因此要重新建立。

微信小程序
1、简单描述下微信小程序的相关文件类型？
微信小程序项目结构主要有四个文件类型，如下：
（1）WXML是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。
（2）WXSS是一套样式语言，用于描述WXML的组件样式。
（3）Js逻辑处理，网络请求。
（4）Json小程序设置，如页面注册，页面标题及tabBar。
（5）App.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航样式，配置默认标题。
（6）app.wxss

2、你是怎么封装微信小程序的数据请求的？
（1）将所有的接口放在统一的js文件中导出。
（2）在app.js中创建封装请求数据的方法。
（3）在子页面中调用封装的方法请求数据。

3、有哪些参数传值的方法？
（1）给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或param参数获取。但data-名称不能有大写字母和不可以存放对象。
（2）设置id的方法标识来传值通过e.currentTarget.id获取设置的id的值，然后通过设置全局对象的方法来传递数值。
（3）在navigator中添加参数传值

4、你使用过哪些方法，来提高微信小程序的应用速度？
（1）提高页面加载速度；（2）用户行为预测；（3）减少默认data的大小；（4）组件方案。

5、小程序与原生App哪个好？
小程序除了拥有公众号的低开发成本、低获客成本以及无需下载等优势，在服务请求延时与用户使用体验都得到了较大幅度的提升，使得其能够承受复杂的服务功能以及获得更好的用户体验。

6、简述微信小程序原理？
微信小程序采用js、wxml、wxss三种技术进行开发，从技术讲和现在的前端开发差不多，但深入挖掘的话却有所不同。
Js：首先js的代码是运行在微信app中的，并不是运行在浏览器中，因此一些h5技术的应用，需要微信app提供对应的API支持，而这限制了h5技术的应用，且其不能成为严格的h5，可以称其为伪h5，同理，微信提供独有的某些API，H5也不支持或支持的不是特别好。
Wxml: wxml微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。
Wxss: wxss具有css的大部分特性，但斌不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。
微信框架，是数据驱动的架构模式，它的ui和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。
小程序分为两个部分webview和appService。其中webview主要用来展现ui,appservice有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现ui的渲染、事件的处理。

7、分析下微信小程序的优劣势
优势：
（1）无需下载，通过搜索和扫一扫就可以打开；
（2）良好的用户体验：打开速度快；
（3）开发成本要比App要低；
（4）安卓上可以添加到桌面，与原生App差不多。
（5）为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。
劣势：
（1）限制较多。页面大小不能超过1M.不能打开超过5个层级的页面。
（2）样式单一。小程序的部分组件已经是成型的了，样式不可以修改。
（3）推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。
（4）依托于微信，无法打开后台管理功能。

8、微信小程序于H5的区别？
（1）运行环境不同
传统的HTML5的运行环境是浏览器，包括webview,而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。
（2）开发成本不同
只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的bug
（3）获取系统级权限的不同
系统级权限都可以和微信小程序无缝衔接。
（4）应用在生产环境的运行流畅度

其他

1、简单介绍一下你做过的移动端APP项目研发流程
答：我的移动端APP项目：《硅谷外卖》，这是一个基于vue2.0+webpack+ES6的一个前后台分离的项目，后台负责处理前台应用提交的请求，并给前台应用返回json数据，前台应用负责展现数据，与用户交互，与后台应用交互，可以实现用户的浏览，登录，选购，搜索等功能。
基本流程：
首先对照一般的外卖APP编写整个app的静态页面和样式。然后使用vue-cli搭建项目，对项目源码进行目录设计，在SRC文件夹下分出路由文件夹、路由组件文件夹，非路由组件文件夹、模拟数据接口文件夹，vuex相关模块文件夹，入口JS和应用组件等多个文件，将整个APP分为商家、商品、用户、购物车等多个子模块，并分析每个模块的结构，将每个模块相应的代码单独提取出去创建自己的路由组件，在非路由组件下创建底部FooterGuide组件和头部HeaderTop组件，在HeaderTop中使用slot标签进行组件通信。
在商家路由下又分出食物、评价和商家信息。其中，最为复杂的是食物组件，内部使用了另外三个组件，包括购物车组件，购物车操作组件，食物详情组件，第三方库使用的是better-scroll，实现食物列表的上下滑动。
对于登录路由组件，有短信登录和账号密码登录两种，在router文件夹下的index.js文件中注册登录路由。其中的界面相关效果包括登录方式的切换，手机号合法检查，倒计时效果，切换显示或隐藏密码，前台验证提示。前后台交互包括动态一次性短信，动态一次性图形验证码，获取用户信息，实现自动登录，短信登陆，密码登录，退出登录，其中退出登录使用mint-ui。
共有10个api接口，包括经纬度的获取，商家列表，食物分类的获取，一次性验证码，手机号验证，用户登录登出等。
封装ajax请求进行前后台交互。
下载vuex对项目进行管理，
异步显示数据，
对于用户评价
项目的日期处理使用了自定义过滤器和moment

2、前端安全问题以及解决办法？
我觉得主要有六大安全问题包括：
（1）XSS（cross-site scripting）脚本攻击漏洞；
XSS是前端谈论最多的安全问题，通过输入文本或HTML标签中插入js进行脚本攻击。解决办法是在使用HTML进行转换内容的时候，不用innerHTML改用innerText,或者把<script><iframe>等标签替换掉。
（2）CSRF（cross-site request forgery）漏洞；
对于跨站请求伪造，其实就是对网站中的一些表单提交行为被黑客利用，比如网站登录时存到cookie的一些个人信息，当你访问黑客的网站有一段相同代码隐藏div，但你点击的时候会导致你的网站被登录或登出，就是在对别的网站进行操作的时候会对你之前的网站发送请求。
解决办法是增加token验证避免攻击，referer验证对页面来源进行判断。
（3）iframe安全隐患问题；
对于Iframe安全隐患问题，可以使用安全的网站进行嵌入。
（4）本地存储数据问题；
可以对放在cookie中或localStorage中的信息进行加密，或使用base64进行多次加密 和解密。
（5）第三方依赖的安全性问题；
利用自动化工具进行扫描
（6）HTTPS加密传输协议；
对接口请求及网站部署等进行HTTPS加密。

3、最近在学什么？能谈谈你未来3，5年给自己的规划吗？
最近在学习微信小程序开发，正在做一款名为《豆瓣电影》的微信小程序，近期的目标是微信小程序以及react框架。长期计划，在未来的三至五年依旧从事前端开发，但是之后会慢慢从PC端转向移动端开发，毕竟相较于PC端，移动端的优势更大，在人群中手机的普及率远远大于电脑，在拥有相同功能和享受的情况下，我相信大多数人更愿意使用手机在移动端进行操作，无论是发达地区还是不太发达的地区，移动端更符合大众的消费水平和消费习惯，微信小程序的出现更是使得移动端更加方便和美观。

4、移动端（Android IOS）怎么做好用户体验?
答：清晰的视觉线，信息的分组，极致的减法，利用选择代替输入，标签及文字的排布方式，依靠明文解决密码，合理的键盘利用。

5、你对加班的看法？
答：加班就像借钱，原则应当是——救急不救穷
6、你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？）
答：“移动开发也称为手机开发，或叫做移动互联网开发。是指以手机、PDA、UMPC等便携终端为基础，进行相应的开发工作，由于这些随身设备基本都采用无线上网的方式，因此，业内也称作为无线开发。”
单纯的说移动端和PC端的区别，简单的概括就是移动端的网页开发比pc端更加开发，更加简单，页面小，装的东西少，css和html写的就少了，交互也简单。

7、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？
答：前端是最贴近用户的程序员，前端的能力就是让产品从90分进化到100分，甚至更好，可以实现界面交互实现界面交互，提升用户体验，比后端、数据库、产品经理、运营、安全都近。

8、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）
答：（1）浏览器会开启一个线程来处理这个请求，对URL分析判断，如果是http协议就按照web方式来处理；
（2）调用浏览器内核中的对应方法，比如webview中localUrl方法；
（3）通过DNS解析获取网址的IP地址，设置UA等信息发出第二个GET请求；
（4）进行HTTP协议会话，客户端发送报头；
（5）进入到web服务器上的web serer
（6）进入到部署好的后端应用，找到对应的请求处理；
（7）处理结束回馈报头，此处若浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致返回304；
（8）浏览器开始下载html文档，同时使用缓存。
（9）文档树建立，根据标记请求所需指定类型的文件，同时设置cookie
（10）页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定，页面显示完成。

9、http状态码有那些？分别代表是什么意思？
答：（1）1**(信息类)：表示接收到请求并且继续处理
2**(响应成功)：表示动作被成功接收、理解和接受
3**(重定向类)：为了完成指定的动作，必须接受进一步处理
4**(客户端错误类)：请求包含错误语法或不能正确执行
5**(服务端错误类)：服务器不能正确执行一个正确的请求
1**(信息类)：表示接收到请求并且继续处理
  	100——客户必须继续发出请求
  	101——客户要求服务器根据请求转换HTTP协议版本

    2**(响应成功)：表示动作被成功接收、理解和接受
  	200——表明该请求被成功地完成，所请求的资源发送回客户端
  	201——提示知道新文件的URL
  	202——接受和处理、但处理未完成
  	203——返回信息不确定或不完整
  	204——请求收到，但返回信息为空
  	205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
  	206——服务器已经完成了部分用户的GET请求

    3**(重定向类)：为了完成指定的动作，必须接受进一步处理
  	300——请求的资源可在多处得到
  	301——本网页被永久性转移到另一个URL
  	302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
  	303——建议客户访问其他URL或访问方式
  	304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
  	305——请求的资源必须从服务器指定的地址得到
  	306——前一版本HTTP中使用的代码，现行版本中不再使用
  	307——申明请求的资源临时性删除

    4**(客户端错误类)：请求包含错误语法或不能正确执行
  	400——客户端请求有语法错误，不能被服务器所理解
  	401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
  	HTTP 401.1 - 未授权：登录失败
  	　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
  	　　HTTP 401.3 - ACL 禁止访问资源
  	　　HTTP 401.4 - 未授权：授权被筛选器拒绝
  	HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
  	402——保留有效ChargeTo头响应
  	403——禁止访问，服务器收到请求，但是拒绝提供服务
  	HTTP 403.1 禁止访问：禁止可执行访问
  	　　HTTP 403.2 - 禁止访问：禁止读访问
  	　　HTTP 403.3 - 禁止访问：禁止写访问
  	　　HTTP 403.4 - 禁止访问：要求 SSL
  	　　HTTP 403.5 - 禁止访问：要求 SSL 128
  	　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
  	　　HTTP 403.7 - 禁止访问：要求客户证书
  	　　HTTP 403.8 - 禁止访问：禁止站点访问
  	　　HTTP 403.9 - 禁止访问：连接的用户过多
  	　　HTTP 403.10 - 禁止访问：配置无效
  	　　HTTP 403.11 - 禁止访问：密码更改
  	　　HTTP 403.12 - 禁止访问：映射器拒绝访问
  	　　HTTP 403.13 - 禁止访问：客户证书已被吊销
  	　　HTTP 403.15 - 禁止访问：客户访问许可过多
  	　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效
  	HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
  	404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
  	405——用户在Request-Line字段定义的方法不允许
  	406——根据用户发送的Accept拖，请求资源不可访问
  	407——类似401，用户必须首先在代理服务器上得到授权
  	408——客户端没有在用户指定的饿时间内完成请求
  	409——对当前资源状态，请求不能完成
  	410——服务器上不再有此资源且无进一步的参考地址
  	411——服务器拒绝用户定义的Content-Length属性请求
  	412——一个或多个请求头字段在当前请求中错误
  	413——请求的资源大于服务器允许的大小
  	414——请求的资源URL长于服务器允许的长度
  	415——请求资源不支持请求项目格式
  	416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
  	417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。

    5**(服务端错误类)：服务器不能正确执行一个正确的请求
  	HTTP 500 - 服务器遇到错误，无法完成请求
  	　　HTTP 500.100 - 内部服务器错误 - ASP 错误
  	　　HTTP 500-11 服务器关闭
  	　　HTTP 500-12 应用程序重新启动
  	　　HTTP 500-13 - 服务器太忙
  	　　HTTP 500-14 - 应用程序无效
  	　　HTTP 500-15 - 不允许请求 global.asa
  	　　Error 501 - 未实现
    HTTP 502 - 网关错误
    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常

10、你有用过哪些前端性能优化的方法？
答：（1）减少HTTP请求次数；
（2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费；
（3）用innerHTML代替DOM操作；
（4）当需要设置的样式很多时设置className而不是直接使用style
（5）少用全局变量、缓存DOM节点查找的结果
（6）图片预加载
（7）避免在页面的主题布局中使用table;

11、介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
JS引擎则：解析和执行javascript来实现网页的动态效果。
最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

12、undefined和null的区别
Undefined类型只有一个值，即undefined,当声明的变量还未被初始化时，变量默认值为undefined.
null类型也直接有一个值，即null,null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。


13、NAN
NAN属性是代表非数字值的特殊值，该属性用来指示某个值不是数字

14、GET和POST的区别
Get用于获取信息，是无副作用的，是幂等的，且可缓存，post用于修改服务器上的数据，有副作用，非幂等，不可缓存。
GET和POST都是HTTP协议中两种请求方式，而HTTP协议是基于TCP/IP的应用协议，无论GET还是POST，用的都是同一个传输层协议，所以再传输上没有区别。

15、什么叫优雅降级和渐进增强？
优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow
渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；
16、列举IE与其他浏览器不一样的特性？
（1）事件不同之处：
触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性；
获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性；
阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法；
停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()；



1、HTML5的form如何关闭自动完成功能？
 给不想要提示的 form 或某个 input 设置为 autocomplete=off。
2、如何实现浏览器内多个标签页之间的通信? (阿里)
 WebSocket、SharedWorker；
  也可以调用localstorge、cookies等本地存储方式；
localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，
我们通过监听事件，控制它的值来进行页面信息通信；
注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；
3、webSocket如何兼容低浏览器？(阿里)
Adobe Flash Socket 、ActiveX HTMLFile (IE) 、基于 multipart 编码发送 XHR 、基于长轮询的 XHR
4、页面可见性（Page Visibility API） 可以有哪些用途？
通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;
在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；
5、如何在页面上实现一个圆形的可点击区域？
（1）map+area或者svg
（2）border-radius
（3）纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等
6、实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。
<div style="height:1px;overflow:hidden;background:red"></div>
7、网页验证码是干嘛的，是为了解决什么安全问题。
区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；
有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。
8、title与h1的区别、b与strong的区别、i与em的区别？
title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；
strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<B>是展示强调内容。
i内容展示为斜体，em表示强调的文本；
Physical Style Elements -- 自然样式标签
b, i, u, s, pre
Semantic Style Elements -- 语义样式标签
strong, em, ins, del, code
应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。
CSS
1、CSS优先级算法如何计算？
*   优先级就近原则，同权重情况下样式定义最近者为准;
*   载入样式以最后载入的定位为准;
优先级为:
同权重: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。
!important >  id > class > tag	
important 比 内联优先级高
2、CSS3新增伪类有那些？
举例：
p:first-of-type	选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
p:last-of-type	选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
p:only-of-type	选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
p:only-child		选择属于其父元素的唯一子元素的每个 <p> 元素。
p:nth-child(2)	选择属于其父元素的第二个子元素的每个 <p> 元素。
::after			在元素之前添加内容,也可以用来做清除浮动。
::before			在元素之后添加内容
:enabled  		
:disabled 		控制表单控件的禁用状态。
:checked        单选框或复选框被选中。
3、如何居中div？
水平居中：给div设置一个宽度，然后添加margin:0 auto属性
div{
width:200px;
margin:0 auto;}
让绝对定位的div居中
div {
position: absolute;
width: 300px;
height: 300px;
margin: auto;
top: 0;
left: 0;
bottom: 0;
right: 0;
background-color: pink;	/* 方便看效果 */
}
水平垂直居中一
确定容器的宽高 宽500 高 300 的层
设置层的外边距
div {
 	position: relative;		/* 相对定位或绝对定位均可 */
 	width:500px;
 	height:300px;
 	top: 50%;
 	left: 50%;
 	margin: -150px 0 0 -250px;     	/* 外边距为自身宽高的一半 */
 	background-color: pink;	 	/* 方便看效果 */
  }
水平垂直居中二
 未知容器的宽高，利用 `transform` 属性
div {
	position: absolute;		/* 相对定位或绝对定位均可 */
 	width:500px;
 	height:300px;
 	top: 50%;
 	left: 50%;
 	transform: translate(-50%, -50%);
 	background-color: pink;	 	/* 方便看效果 */
}
水平垂直居中三
利用 flex 布局
实际使用时应考虑兼容性
.container {
 	display: flex;
 	align-items: center; 		/* 垂直居中 */
 	justify-content: center;	/* 水平居中 */
}
 .container div {
 	width: 100px;
 	height: 100px;
 	background-color: pink;		/* 方便看效果 */
 }  
4、display有哪些值？说明他们的作用。
block    	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。
none        	元素不显示，并从文档流中移除。
inline      	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。
list-item   	象块类型元素一样显示，并添加样式列表标记。
table       	此元素会作为块级表格来显示。
inherit     	规定应该从父元素继承 display 属性的值。
5、用纯CSS创建一个三角形的原理是什么？
  把上、左、右三条边隐藏掉（颜色设为 transparent）
  #demo {
    width: 0;
    height: 0;
    border-width: 20px;
    border-style: solid;
    border-color: transparent transparent red transparent;
  }
6、一个满屏 品 字布局 如何设计?
  简单的方式：
  	上面的div宽100%，
  	下面的两个div分别宽50%，
  	然后用float或者inline使其不换行即可
7、css多列等高如何实现？
  利用padding-bottom|margin-bottom正负值相抵；
  设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，
  当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，
  其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。
8、CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？
对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同. 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.
position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？
如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠.
9、css定义的权重
 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：
  /*权重为1*/
  div{
  }
  /*权重为10*/
  .class1{
  }
  /*权重为100*/
  #id1{
  }
  /*权重为100+1=101*/
  #id1 div{
  }
  /*权重为10+1=11*/
  .class1 div{
  }
  /*权重为10+10+1=21*/
  .class1 .class2 div{
  }
  如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现
10、请解释一下为什么需要清除浮动？清除浮动的方式
清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。
（1）父级div定义height；
（2）父级div 也一起浮动；
（3）常规的使用一个class；
  	.clearfix::before, .clearfix::after {
  	    content: " ";
  	    display: table;
  	}
  	.clearfix::after {
  	    clear: both;
  	}
  	.clearfix {
  	    *zoom: 1;
  	}

（4）SASS编译的时候，浮动元素的父级div定义伪类:after
  	&::after,&::before{
  	    content: " ";
          visibility: hidden;
          display: block;
          height: 0;
          clear: both;
  	}
  解析原理：
  1) display:block 使生成的元素以块级元素显示,占满剩余空间;
  2) height:0 避免生成内容破坏原有布局的高度。
  3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;
  4）通过 content:"."生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:".",有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”" 仍然会产生额外的空隙；
  5）zoom：1 触发IE hasLayout。
  通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。
11、什么是外边距合并？
  外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。
  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
  w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp
12、zoom:1的清除浮动原理?
  清除浮动，触发hasLayout；
  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。
  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。
  来龙去脉大概如下：
  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。
  Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。
  目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？
  可以通过css3里面的动画属性scale进行缩放。
13、移动端的布局用过媒体查询吗？
假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法
当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。
包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。
<style> @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } </style>
14、CSS优化、提高性能的方法有哪些？
  关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；
  如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；
  提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;
  使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；
15、浏览器是怎样解析CSS选择器的？
  样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。
  只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。
16、在网页中的应该使用奇数还是偶数的字体？为什么呢？
（1）比例关系。相对来说偶数字号比较容易和页面中其他部分的字号构成一个比例关系。如我使用14px的字体作为正文字号，那么其他部分的字体（如标题）就可以使用14×1.5 =21px的字体，或者在一些地方使用到了14×0.5=7px的padding或者margin，如果你是在用sass或者less编写css，这时候用处就凸显出来了。
（2）UI设计师的缘故。大多数设计师用的软件按如PS提供的字号都是偶数，自然前端也是偶数。
（3）浏览器的缘故。其一是低版本的浏览器Ie6会把奇数字体强制转化为偶数。其二是为了平分字体。偶数宽的汉字，如12px的汉子，去掉1像素的字体间距，填充了的字体像素宽度其实就是11px，这样的汉字中竖线左右是平分的，如“中”子，左右就是5px了。
（4）系统差别。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。而在Linux和其他手持设备上，奇数偶数的渲染效果其实相差不大。
17、margin和padding分别适合什么场景使用？
  margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。
  margin用于布局分开元素使元素与元素互不相干；
  padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段
18、抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]
19、元素竖向的百分比设定是相对于容器的高度吗？
当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如padding-top,padding-bottom,margin-top,margin-bottom等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。
20、全屏滚动的原理是什么？用到了CSS的那些属性？
原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现。
21、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？
响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及 使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局，无论用户正在使用笔记本还是iPad，我们 的页面都应该能够自动切换分辨率、图片尺寸及相关脚本功能等，以适应不同设备。
响应式Web设计不仅仅是关于屏幕分辨率自适应以及自动缩放的图片等等，它更像是一种对于设计的全新思维模式, 如我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏(portrait)、横屏(landscape)，怎样才能做到让一种 设计方案满足所有情况？
基本原理: 媒体查询 @media
兼容IE可以使用JS辅助一下来解决
22、视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）
视差滚动（Parallax Scrolling）就是这样的效果之一。这种技术通过在网页向下滚动的时候，控 
制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。
原理：（1）CSS3实现
优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器
（2）jquery实现
通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。
优点：能兼容到各个版本的，效果可控性好
缺点：开发起来对制作者要求高
（3）插件实现方式
例如：parallax-scrolling，兼容性十分好
23、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。
  单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）
  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，
  比如:first-line、:first-letter、:before、:after等，
  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。
  想让插入的内容出现在其它内容前，使用::before，否者，使用::after；
  在代码顺序上，::after生成的内容也比::before生成的内容靠后。
  如果按堆栈视角，::after生成的内容会在::before生成的内容之上
24、如何修改chrome记住密码后自动填充表单的黄色背景 ？
  input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {
    background-color: rgb(250, 255, 189); /* #FAFFBD; */
    background-image: none;
    color: rgb(0, 0, 0);
  }
25、你对line-height是如何理解的？
设置元素浮动后，该元素的display值是多少？
  自动变成了 display:block
26、怎么让Chrome支持小于12px 的文字？
 （1）用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。
  （2）使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。
  （3）继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。
  （4）使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。
27、让页面里的字体变清晰，变细用CSS怎么做？
  -webkit-font-smoothing: antialiased;
28、font-style属性可以让它赋值为“oblique” oblique是什么意思？
  倾斜的字体样式
29、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）
  多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms
30、display:inline-block 什么时候会显示间隙？(携程)
  移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing
31、overflow: scroll时不能平滑滚动的问题怎么处理？
（1）减少页面的dom节点数量，一个好的页面不能有太多太复杂的页面结构，影响页面渲染时候，页面渲染时间，具体的可以通过“document.getElementsByTagName('*').length”检查，可以去看看已知的好的页面，看看他们的节点数来评估。
（2）适当的节流，做一个假的滚动条，然后监听，当移动到一定程度时候，调整目标区域的scroll-top值。这样会大量减少，浏览器重绘次数，并列表结构时有较好体验。
32、有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。
三种解法：
（1）css3弹性盒子(Flex Box)解法：
CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。
引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。
display:flex或display:inline-flex:指定父元素为弹性盒子;
flex-direction:指定flex子项在flex父元素中的排列方式。
flex-direction属性取值：
1）row：主轴与行内轴方向作为默认的书写模式。即横向从左到右排列（左对齐）。
2）row-reverse：对齐方式与row相反。
3）column：主轴与块轴方向作为默认的书写模式。即纵向从上往下排列（顶对齐）。
4）column-reverse：对齐方式与column相反。
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="gb2312">
    <title>Title</title>
    <style>
        .box {
            width:200px;
            height:300px;
            background:red;
            display:flex;
            display: -webkit-flex;
            flex-direction:column;
            -webkit-flex-direction:row;}
        .a {height:100px;background:green;}
        .b {background:blue;flex:1}
    </style>
</head>
<body>
    <div class="box">
        <div class="a"></div>
        <div class="b"></div>
    </div>
</body>
</html>

（2）纯css解法：
*外容器：position:relative。高度固定为100px的盒子使用相对定位，高度要求自适应的盒子使用绝对定位，再设定它的top：100px;left:0;bottom:0;
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="gb2312">
    <title>Title</title>
    <style>
        body { height: 100%; padding: 0; margin: 0; }
        .box { height: 400px; position: relative; }
        .a { height: 100px; background: #ff0000; }
        .b { background: #00ff00; width: 100%; position: absolute; top: 100px ; left: 0 ; bottom: 0;}
    </style>
</head>
<body>
<div class="box">
    <div class="a"></div>
    <div class="b"></div>
</div>
</body>
</html>
（2）js解法：
获取外层盒子和固定高度盒子的高度值，将其相减，结果就是自适应盒子的高度.
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="gb2312">
    <title>Title</title>
    <script type="text/javascript" src="js/jquery-1.11.1.min.js"></script>
    <style>
        body { height: 100%; padding: 0; margin: 0; }
        #box { height: 400px; position: relative; }
        #a { height: 100px; background: #ff0000; }
        #b { background: #00ff00; width: 100%; }
    </style>
</head>
<body>
<div id="box">
    <div id="a"></div>
    <div id="b"></div>
</div>
</body>
<script language="javascript" >
    $(document).ready(function() {
        var h1 = $("#box").height();
        var h2 = $("#a").height();
        var h3 = h1-h2;
        $("#b").css("height",h3);
    })
</script>
</html>
33、什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）
  如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，
  所以不如隔离开。
  因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，
  这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。
  同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，
  提高了webserver的http请求的解析速度。
34、style标签写在body后与body前有什么区别？
（1）写在body标签前利于浏览器逐步渲染。
Resources downloading -> CSSOM+DOM ->RenderTree(composite) -> Layout ->paint
（2）写在body标签之后。由于浏览器以逐行方式对html文档进行解析。当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染；在windows的IE下可能会出现fouce现象（即样式失效导致的页面闪烁问题）；
JavaScript
1、介绍js的基本数据类型。
  Undefined、Null、Boolean、Number、String、
  ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )
2、介绍js有哪些内置对象？
 Object 是 JavaScript 中所有对象的父对象
 数据封装类对象：Object、Array、Boolean、Number 和 String
 其他对象：Function、Arguments、Math、Date、RegExp、Error
 参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html
3、说几条写JavaScript的基本规范？
 （1）不要在同一行声明多个变量。
 （2）请使用 ===/!==来比较true/false或者数值
 （3）使用对象字面量替代new Array这种形式
 （4）不要使用全局函数。
 （5）Switch语句必须带有default分支
 （6）函数不应该有时候有返回值，有时候没有返回值。
 （7）For循环必须使用大括号
 （8）If语句必须使用大括号
 （9）for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。
4、JavaScript原型，原型链 ? 有什么特点？
 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
 于是就这样一直找下去，也就是我们平时所说的原型链的概念。
 关系：instance.constructor.prototype = instance.__proto__
 特点：
 JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
  当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
  就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。
 	function Func(){}
 	Func.prototype.name = "Sean";
 	Func.prototype.getInfo = function() {
 	  return this.name;
 	}
 	var person = new Func();//现在可以参考var person = Object.create(oldObject);
 	console.log(person.getInfo());//它拥有了Func的属性和方法
 	//"Sean"
 	console.log(Func.prototype);
 	// Func { name="Sean", getInfo=function()}
5、JavaScript有几种类型的值？，你能画一下他们的内存图吗？
 栈：原始数据类型（Undefined，Null，Boolean，Number、String）
 堆：引用数据类型（对象、数组和函数）
 两种类型的区别是：存储位置不同；
 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
6、如何将字符串转化为数字，例如'12.3b'?
  * parseFloat('12.3b');
  * 正则表达式，'12.3b'.match(/(\d)+(\.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。
7、如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?
  function commafy(num){
  	return num && num
  		.toString()
  		.replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2){
  			return $2 + ',';
  		});
  }
8、如何实现数组的随机排序？
  方法一：
  	var arr = [1,2,3,4,5,6,7,8,9,10];
  	function randSort1(arr){
  		for(var i = 0,len = arr.length;i < len; i++ ){
  			var rand = parseInt(Math.random()*len);
  			var temp = arr[rand];
  			arr[rand] = arr[i];
  			arr[i] = temp;
  		}
  		return arr;
  	}
  	console.log(randSort1(arr));  	
  方法二：
  	var arr = [1,2,3,4,5,6,7,8,9,10];
  	function randSort2(arr){
  		var mixedArray = [];
  		while(arr.length > 0){
  			var randomIndex = parseInt(Math.random()*arr.length);
  			mixedArray.push(arr[randomIndex]);
  			arr.splice(randomIndex, 1);
  		}
  		return mixedArray;
  	}
  	console.log(randSort2(arr));
  方法三：
  	var arr = [1,2,3,4,5,6,7,8,9,10];
  	arr.sort(function(){
  		return Math.random() - 0.5;
  	})
  	console.log(arr);
9、Javascript如何实现继承？
 （1）构造继承
 （2）原型继承
 （3）实例继承
 （4）拷贝继承
 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。 
 	function Parent(){
 		this.name = 'wang';
 	}
 	function Child(){
 		this.age = 28;
 	}
 	Child.prototype = new Parent();//继承了Parent，通过原型
 	var demo = new Child();
 	alert(demo.age);
 	alert(demo.name);//得到被继承的属性
10、JavaScript继承的几种实现方式？
（一）原型链
ECMAScript中将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。（不理解原型链的童鞋们可以翻阅一下我之前的博客，里面有详细的说明）
实现原型链的一种基本模式。
原型链虽然很强大，可以实现继承，但存在两个主要的问题。（1）包含引用类型值的原型属性会被所有实例共享，这会导致对一个实例的修改会影响另一个实例。（2）在创建子类型的实例时，不能向超类型的构造函数中传递参数。由于这两个问题的存在，实践中很少单独使用原型链。
（二）借用构造函数
在解决原型中包含引用类型值所带来的问题中，使用借用构造函数技术来解决。借用构造函数的基本思想，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法可以在新创建的对象上执行构造函数。
借用构造函数存在两个问题：（1）无法避免构造函数模式存在的问题，方法都在构造函数中定义，因此无法服用函数。（2）在超类型的原型中定义的方法，对子类型而言是不可见的。因此这种技术很少单独使用。
（三）组合继承
组合继承，指的是将原型链和借用构造函数的技术组合到一起。思路是使用原型链实现对原型方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性。
组合继承避免了原型链和借用构造函数的缺点，融合了他们的优点，是JavaScript中最常用的继承模式。
11、javascript创建对象的几种方式？
 javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。
 （1）对象字面量的方式
 	person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
 （2）用function来模拟无参的构造函数
 	function Person(){}
 	var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class
 	person.name="Mark";
 	person.age="25";
 	person.work=function(){
 	alert(person.name+" hello...");
 	}
 	person.work();
(3)用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）
 	function Pet(name,age,hobby){
 	   this.name=name;//this作用域：当前对象
	   this.age=age;
	   this.hobby=hobby;
 	   this.eat=function(){
 	      alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
 	   }
 	}
 	var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
 	maidou.eat();//调用eat方法
（4）用工厂方式来创建（内置对象）
 	 var wcDog =new Object();
 	 wcDog.name="旺财";
 	 wcDog.age=3;
 	 wcDog.work=function(){
 	   alert("我是"+wcDog.name+",汪汪汪......");
 	 }
 	 wcDog.work();
 （5）用原型方式来创建
 	function Dog(){
 	 }
 	 Dog.prototype.name="旺财";
 	 Dog.prototype.eat=function(){
 	 alert(this.name+"是个吃货");
 	 }
 	 var wangcai =new Dog();
 	 wangcai.eat();
 （6）用混合方式来创建
 	function Car(name,price){
 	  this.name=name;
 	  this.price=price;
 	}
 	 Car.prototype.sell=function(){
 	   alert("我是"+this.name+"，我现在卖"+this.price+"万元");
 	  }
 	var camry =new Car("凯美瑞",27);
 	camry.sell();
12、Javascript作用链域?
 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。
 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，
 直至全局函数，这种组织形式就是作用域链。
13、谈谈This对象的理解。
this总是指向函数的直接调用者（而非间接调用者）；
如果有new关键字，this指向new出来的那个对象；
在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；
14、eval是做什么的？
 它的功能是把对应的字符串解析成JS代码并运行；
 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');
15、什么是window对象? 什么是document对象?
 window对象是指浏览器打开的窗口。
 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。
16、写一个通用的事件侦听器函数。
 	// event(事件)工具集，来源：github.com/markyun
 	markyun.Event = {
 		// 页面加载完成后
 		readyEvent : function(fn) {
 			if (fn==null) {
 				fn=document;
 			}
 			var oldonload = window.onload;
 			if (typeof window.onload != 'function') {
 				window.onload = fn;
 			} else {
 				window.onload = function() {
 					oldonload();
 					fn();
 				};
 			}
 		},
 		// 视能力分别使用dom0||dom2||IE方式 来绑定事件
 		// 参数： 操作的元素,事件名称 ,事件处理程序
 		addEvent : function(element, type, handler) {
 			if (element.addEventListener) {
 				//事件类型、需要执行的函数、是否捕捉
 				element.addEventListener(type, handler, false);
 			} else if (element.attachEvent) {
 				element.attachEvent('on' + type, function() {
 					handler.call(element);
 				});
 			} else {
 				element['on' + type] = handler;
 			}
 		},
 		// 移除事件
 		removeEvent : function(element, type, handler) {
 			if (element.removeEventListener) {
 				element.removeEventListener(type, handler, false);
 			} else if (element.datachEvent) {
 				element.detachEvent('on' + type, handler);
 			} else {
 				element['on' + type] = null;
 			}
 		},
 		// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
 		stopPropagation : function(ev) {
 			if (ev.stopPropagation) {
 				ev.stopPropagation();
 			} else {
 				ev.cancelBubble = true;
 			}
 		},
 		// 取消事件的默认行为
 		preventDefault : function(event) {
 			if (event.preventDefault) {
 				event.preventDefault();
 			} else {
 				event.returnValue = false;
 			}
 		},
 		// 获取事件目标
 		getTarget : function(event) {
 			return event.target || event.srcElement;
 		},
 		// 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
 		getEvent : function(e) {
 			var ev = e || window.event;
 			if (!ev) {
 				var c = this.getEvent.caller;
 				while (c) {
 					ev = c.arguments[0];
 					if (ev && Event == ev.constructor) {
 						break;
 					}
 					c = c.caller;
 				}
 			}
 			return ev;
 		}
 	};
13、["1", "2", "3"].map(parseInt) 答案是多少？
 parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，
 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;
 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。
 function parseInt(str, radix) {
     return str+'-'+radix;
 };
 var a=["1", "2", "3"];
 a.map(parseInt);  // ["1-0", "2-1", "3-2"] 不能大于radix
 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN
 所以["1", "2", "3"].map(parseInt) 答案也就是：[1, NaN, NaN]
 详细解析：http://blog.csdn.net/justjavac/article/details/19473199
14、事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？
  （1） 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
  （2） 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；
  （3）ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）
15、javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？
 use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,
 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。
 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;
 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；
 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;
 提高编译器效率，增加运行速度；
 为未来新版本的Javascript标准化做铺垫。
16、new操作符具体干了什么呢?
（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
（2）属性和方法被加入到 this 引用的对象中。
（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。
 var obj  = {};
 obj.__proto__ = Base.prototype;
 Base.call(obj);
17、用原生JavaScript的实现过什么功能吗？
18、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？
 hasOwnProperty
 javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。
 使用方法：
 object.hasOwnProperty(proName)
 其中参数object是必选项。一个对象的实例。
 proName是必选项。一个属性名称的字符串值。
 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。
19、JSON 的了解？
 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
 如：{"age":"12", "name":"back"}
 JSON字符串转换为JSON对象:
 var obj =eval('('+ str +')');
 var obj = str.parseJSON();
 var obj = JSON.parse(str);
 JSON对象转换为JSON字符串：
 var last=obj.toJSONString();
 var last=JSON.stringify(obj);
20、js延迟加载的方式有哪些？
 defer和async、动态创建DOM方式（用得最多）、按需异步载入js
21、Ajax 是什么? 如何创建一个Ajax？
 ajax的全称：Asynchronous Javascript And XML。
 异步传输+js+xml。
 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。
 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象
 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
 (3)设置响应HTTP请求状态变化的函数
 (4)发送HTTP请求
 (5)获取异步调用返回的数据
 (6)使用JavaScript和DOM实现局部刷新
22、Ajax 解决浏览器缓存问题？
  （1）在ajax发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")。
  （2）在ajax发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。
  （3）在URL后面加上一个随机数： "fresh=" + Math.random();。
（4）在URL后面加上时间戳："nowtime=" + new Date().getTime();。
  （5）如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。
23、同步和异步的区别?
同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.
同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。
异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。
24、如何解决跨域问题?
 jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面
25、页面编码和被请求的资源编码如果不一致如何处理？
对于 ajax 请求传递的参数，如果是 get 请求方式，参数如果传递中文，在有些浏览器 会乱码，不同的浏览器对参数编码的处理方式不同，所以对于 get 请求的参数需要使用 encodeURIComponent 函数对参数进行编码处理，后台开发语言都有相应的解码 api。对于 post 请求不需要 进行编码。
26、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？
AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD
CMD 规范在这里：https://github.com/seajs/seajs/issues/242
 Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。
  区别：
（1）对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
（2）CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：
// CMD
define(function(require, exports, module) {
     var a = require('./a')
     a.doSomething()
     // 此处略去 100 行
     var b = require('./b') // 依赖可以就近书写
     b.doSomething()
     // ...
 })
// AMD 默认推荐
 define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
     a.doSomething()
     // 此处略去 100 行
     b.doSomething()
     // ...
 })
26、JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？
https://www.jb51.net/article/99337.htm
https://www.cnblogs.com/jide/p/7136775.html
28、谈一谈你对ECMAScript6的了解？
29、ECMAScript6 怎么写class么，为什么会出现class这种东西?
30、异步加载JS的方式有哪些？
   (1) defer，只支持IE
   (2) async：
   (3) 创建script，插入到DOM中，加载完毕后callBack
31、documen.write和 innerHTML的区别
  document.write只能重绘整个页面
  innerHTML可以重绘页面的一部分
32、DOM操作——怎样添加、移除、移动、复制、创建和查找节点?
  （1）创建新节点
    createDocumentFragment()    //创建一个DOM片段
    createElement()   //创建一个具体的元素
    createTextNode()   //创建一个文本节点
  （2）添加、移除、替换、插入
    appendChild()
    removeChild()
    replaceChild()
    insertBefore() //在已有的子节点前插入一个新的子节点
  （3）查找
    getElementsByTagName()    //通过标签名称
    getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
    getElementById()    //通过元素Id，唯一性
33、.call() 和 .apply() 的区别？
   例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);
   注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。
 	function add(a,b)
 	{
 	    alert(a+b);
 	}
 	function sub(a,b)
 	{
 	    alert(a-b);
 	}
 	add.call(sub,3,1);
35、数组和对象有哪些原生方法，列举一下？
一、数组API
var arr = [1,2,3,4,5,6];
1-forEach遍历所有元素
arr.forEach(function(item,index){
console.log(index+":"+item);
});
2-every判断所有元素是否都符合条件
var result = arr.every(function(item,index){
if(item<5){
return true;
}
});
console.log(result);//不是所有元素都满足，所以返回false
3-some判断是否有至少一个元素符合条件
var result = arr.some(function(item,index){
if(item<5){
return true;
}
});
console.log(result);//true
4-sort排序
arr.sort(function(a,b){
return b-a;
});
console.log(arr);
5-map对元素重新组装，生成新数组
var result = arr.map(function(item,index){
return "<b>"+item+"</b>";
});
console.log(result);//["<b>1</b>", "<b>2</b>", "<b>3</b>", "<b>4</b>", "<b>5</b>", "<b>6</b>"]
6-filter过滤符合条件的元素
var result = arr.filter(function(item,index){
if(item<5){
return true;
}
});
console.log(result);//[1, 2, 3, 4]
二、对象API
1、for-in遍历对象属性
var obj = {
x:100,
y:200,
z:function(){}
}
function A(name){
this.name = name;
}
var obj = new A("ycc");
A.prototype.age = 20;
var key;
for(key in obj){
if(obj.hasOwnProperty(key)){
console.log(key,obj[key]);//key:键 obj[key]:值
}
}
35、JS 怎么实现一个类。怎么实例化这个类
36、JavaScript中的作用域与变量声明提升？
https://blog.csdn.net/P_127/article/details/78593104
一、变量作用域 
说到这个概念，不有自主的想到this,scope 这两个关键字。
JavaScript的this总是指向一个明确的对象，这个对象是在执行的时候动态绑定的。通俗的说就是谁调用我，我的this就是谁。 
除去不常用的with和eval，具体的实际应用中，this的指向分为以下四种情况：
    ·作为对象的调用；
    ·作为普通函数的调用；
    ·构造器的调用；
·Function.propotype.call 和 Functio.propotype.apply 调用；
二、变量声明提升 
当我们的声明在同作用域靠后的位置，变量的声明会被自动提升到作用域的开头。 
当我们如下声明一个变量
var a=100;
其实做了三件事：声明变量、执行变量的数据类型、赋值。
36、如何编写高性能的Javascript？
（1）尽量不要用for-in循环去访问数组，建议用for循环进行循环。
function foo() {
var i, b, c=[,,];
for (i in c) {
b = c[i];
if(b === "")
return b;
}
}
//性能更好
function foo() {
var i, b, c=[,,];
for (i=;i<c.length;i++) {
b = c[i];
if(b === "")
return b;
}
} 
（2）建议讲对象进行缓存处理，特别是DOM访问是比较消耗资源的。
//c.length没有缓存，每次迭代都要计算一下数组的长度
function foo() {
var i, b, c=[,,];
for (i=;i<c.length;i++) {
b = c[i];
if(b === "")
return b;
}
}
//性能更好，第一次将数组的长度缓存到变量l中，第二次及后续的循环无需计算数组长度
function foo() {
var i, b, c=[,,],l;
for (i=,l=c.length;i<l;i++) {
b = c[i];
if(b === "")
return b;
}
}

//document.getElementById('info')没有缓存，每次都要遍历DOM
function foo() {
var e;
document.getElementById('info').innerHTML="call ";
document.getElementById('info').innerHTML="call ";
}
//性能更好，第二次无需访问DOM
function foo() {
var e=document.getElementById('info');
e.innerHTML="call ";
e.innerHTML="call ";
}
（3）建议不要在函数内进行过深的嵌套判断。
//函数内嵌套判断语句过多
function foo1() {
var r={};
r.data={};
r.data.myProp=2;
if (r) {
if (r.data) {
if (r.data.myProp) {
//逻辑处理
}
else {
//逻辑处理
}
}
}
}
//性能更好
function foo2() {
var r={};
r.data={};
r.data.myProp=2;
if (!r) return;
if (!r.data) return;
if (r.data.myProp) {
//逻辑处理
} else {
//逻辑处理
}
}
（4）避免你循环引用，防止内存泄漏
//需要jQuery
function foo(e,d) {
$(e).on("click", function() {
//对d进行逻辑处理
cbk(d);
}
});
}
//打破循环!
function foo(e, d) {
$(e).on("click", cbk(d));
}
function cbk (d) {
//逻辑处理
}
（5）建议避免啊在函数内返回一个未声明的变量，会污染外部变量
function foo(a, b) {
r = a + b;
return r; //r未声明，则创建了一个全局变量
}
（6）var声明变量，建议写在多行
//自己测试结果是foo快，但也有一种观点是foo快
function foo() {
var c = ;
var sum=;
var d = ;
var e;
}
function foo() {
var c = ,sum=, d = , e;
}
37、那些操作会造成内存泄漏？
(1)意外的全局变量引起的内存泄漏
(2)闭包引起的内存泄漏
(3)没有清理的DOM元素引用
(4)被遗忘的定时器或者回调
(5)子元素存在引起的内存泄漏
(6)IE7/8引用计数使用循环引用产生的问题
38、怎样避免内存泄漏
（1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；
（2）注意程序逻辑，避免“死循环”之类的；
（3）避免创建过多的对象，原则：不用的东西要及时归还。
39、JQuery的源码看过吗？能不能简单概况一下它的实现原理？
https://www.cnblogs.com/zuoxiaolong/p/jquery1.html
40、jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？
返回的this就是jQuery.fn的实例
41、jquery中如何将数组转化为json字符串，然后再转化回来？
jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：
	$.fn.stringifyArray = function(array) {
	    return JSON.stringify(array)
	}
	$.fn.parseArray = function(array) {
	    return JSON.parse(array)
	}
	然后调用：
	$("").stringifyArray(array)
42、jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？
https://blog.csdn.net/jiang7701037/article/details/98758955
43、jquery.extend 与 jquery.fn.extend的区别？
 * jquery.extend 为jquery类添加类方法，可以理解为添加静态方法
 * jquery.fn.extend:
        源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数
 使用：
 jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。
44、jQuery 的队列是如何实现的？队列可以用在哪些地方？
45、谈一下Jquery中的bind(),live(),delegate(),on()的区别？
.bind()方法将事件类型和一个事件处理函数直接注册到了被选中的DOM元素中。这个方法被使用得最久,在此期间,它很好的解决了各种跨浏览器的问题。
.bind()方法将会把事件处理函数连接到所有匹配的a标签。这种方式并不好。这样做的话，它不仅在所有匹配的元素中隐含地迭代附加事件处理函数，而且这些操作非常浪费（多余），因为这些相同的事件处理函数是被一遍一遍的重复的添加到所有匹配的标签上。
优点:
（1）适用于各种浏览器
（2）连接事件处理函数非常方便快捷
（3）可以使用 .click() ,  .hover()等简写方法来更方面地连接事件处理函数
（4）对于一个简单的ID选择器,使用.bind() 方法不仅可以很快地连接事件处理函数,而且当事件被触发时, 事件处理函数几乎是马上就被调用了
缺点:
（1）这样方法会将所有的事件处理函数附加到所有匹配的元素
（2）不可以动态地匹配相同选择器的元素
（3）当操作大量匹配的元素时会有性能方面的问题
（4）附加操作是在前期完成的,这可能导致页面加载时存在性能问题
.live()方法使用了事件委托的概念来实施其所谓的“魔法”。你调用live()方法的方式就像是调用bind()方法那样方便。然而在这表面之下， .live()方法与前者的实现方式大不相同。 .live()方法将与事件处理函数关联的选择器和事件信息一起附加到文档的根级元素（即document）。通过将事件信息注册到document上，这个事件处理函数将允许所有冒泡到document的事件调用它（例如委托型、传播型事件）。一旦有一个事件冒泡到document元素上，Jquery会根据选择器或者事件的元数据来决定哪一个事件处理函数应该被调用，如果这个事件处理函数存在的话。这个额外的工作将会在用户交互时对性能方面造成一定的影响，但是初始化注册事件的过程相当地快。
.bind()这个例子与上面bind()方法的例子对比的话有一个优点在于它仅仅把事件处理函数附加到document元素一次，而不是很多次。这样不仅更快，而且还减少了性能的浪费。然而，使用这个方法也会带来很多问题，下面将一一列出。
优点:
（1）所有的事件处理函数都只会被注册一次，而不是像bind()那样进行多次注册
（2）将bind()方法升级到live()方法非常方便，你仅需要将"bind"替代为"live"就可以了
（3）那些被动态添加到DOM的元素也将被神奇的匹配到，因为真实的事件信息是被注册到document元素上的
（4）你可以在文档加载完之前连接事件处理函数，这样可以帮助你更好地利用你可能没有用的时间
缺点:
（1）这个方法在Jquery 1.7以后的版本被弃用了，你应该在你的代码里逐步放弃使用它
（2）使用这个方法时链式操作没有得到正确的支持，可能会出现某些错误
（3）所做的匹配操作基本上没用因为它只用于在document元素上注册事件处理函数
（4）使用 event.stopPropogation() 方法将会没用，因为事件总是已经被委托到了document元素上
（5）因为所有的选择器或者事件信息都被附加到document元素上了，所以一旦有一个事件要调用某个事件处理函数，Jquery会在一大堆储存的元数据中使用matchesSelector方法来决定哪一个事件处理函数将会被调用，如果这个函数有的话。
（6）因为你所连接的事件总是被委托到document上，所如果你的DOM的层级很深的话，这会导致一定的性能问题。
.bind()这个例子与上面bind()方法的例子对比的话有一个优点在于它仅仅把事件处理函数附加到document元素一次，而不是很多次。这样不仅更快，而且还减少了性能的浪费。然而，使用这个方法也会带来很多问题，下面将一一列出。
优点:
（1）所有的事件处理函数都只会被注册一次，而不是像bind()那样进行多次注册
（2）将bind()方法升级到live()方法非常方便，你仅需要将"bind"替代为"live"就可以了
（3）那些被动态添加到DOM的元素也将被神奇的匹配到，因为真实的事件信息是被注册到document元素上的
（4）你可以在文档加载完之前连接事件处理函数，这样可以帮助你更好地利用你可能没有用的时间
缺点:
（1）这个方法在Jquery 1.7以后的版本被弃用了，你应该在你的代码里逐步放弃使用它
（2）使用这个方法时链式操作没有得到正确的支持，可能会出现某些错误
（3）所做的匹配操作基本上没用因为它只用于在document元素上注册事件处理函数
（4）使用 event.stopPropogation() 方法将会没用，因为事件总是已经被委托到了document元素上
（5）因为所有的选择器或者事件信息都被附加到document元素上了，所以一旦有一个事件要调用某个事件处理函数，Jquery会在一大堆储存的元数据中使用matchesSelector方法来决定哪一个事件处理函数将会被调用，如果这个函数有的话。
（6）因为你所连接的事件总是被委托到document上，所如果你的DOM的层级很深的话，这会导致一定的性能问题
.delegate()方法十分强大。在上面这个例子中，与事件处理函数关联的选择器和事件信息将会被附加到( #members" )这个元素上。这样做比使用live()高效多了，因为live()方法总是将与事件处理函数关联的选择器和事件信息附加到document元素上。另外，使用.delegate()方法解决许多其他问题。请参阅下方列出的详细信息。
优点:
（1）你可以选择将选择器或者事件信息附加到指定的元素。
（2）匹配操作实际上在前面并没有执行，而是用来注册到指定的元素。
（3）链式操作可以得到正确的支持
（4）Jquery仍然需要迭代这些选择器或者事件信息来匹配元素，不过因为你可以选择哪一个元素作为根元素，所以筛选的量会大幅减少
（5）因为这项技术使用了事件委托机制，它可以匹配到被动态地添加到DOM的元素
（6）你可以在文档加载完之前连接事件处理函数
缺点:
（1）从.bind()方法不可以直接升级到.delegate()方法
（2）Jquery仍然需要使用marchesSelector方法在附加到指定根元素的选择器或者事件信息中筛选决定哪一个事件处理函数会被调用。然而，附加到指定根元素的元数据会比使用live()方法的时候要小得多。
（3）当操作大量匹配的元素时会有性能方面的问题
（4）附加操作是在前期完成的,这可能导致页面加载时存在性能问题
使用On方法
你知道吗，在Jquery 1.7版本中.bind() ， .live() 和.delegate()方法只需要使用.on()方法一种方式来调用它们。当然.unbind() ， .die() 和.undelegate()方法也一样。
如何使用.on()方法决定了它如何调用其他方法。你可以认为.on()方法被具有不同签名的方法”重载“了，而这些方法实现了不同的事件绑定的连接方式。 .on()方法的出现为API带来了很多方面的一致性，并希望让事情变得不那么混乱。
优点:
（1）使各种事件绑定方法一致。
（2）因为在Jquery源码中.bind() ， .live() 和.delegate()方法实际上是调用了此方法，因此简化了jQuery代码库并删除了一级重定向。
（3）这种方式仍然提供了使用.delegate()方法的优点，并且仍然提供对.bind()方法的支持，如果你需要的话。
缺点:
给人带来了一些疑惑，因为方法的实际执行方式将根据你如何调用方法而改变。
总结
如果你对不同的绑定事件方法有所迷惑，那么不要担心，因为API发展了一段时间了，有很多前人的经验可以借鉴。也有很多人将这些方法视为魔法，不过一旦你了解了他们工作背后的原理，将帮助您了解如何更好地处理项目。
以下是这篇文章的精华所在...
（1）使用.bind()方法非常浪费性能因为它把同一个事件处理函数附加到了每一个匹配的元素上
（2）你应该停止使用.live()方法因为它被弃用了同时也会带来很多问题
（3）使用.delegate()方法会给你带来很多好处当你需要解决一些性能上的问题和对动态添加的元素作出处理
（4）新的.on()方法其实就是模拟.bind() ， .live() 和.delegate()实现的语法糖，具体取决于你如何调用它
（5）新的方向是使用新的.on()方法。先熟悉语法，并开始在你的所有的Jquery 1.7版本以上的项目使用它吧！

46、JQuery一个对象可以同时绑定多个事件，这是如何实现的？
bind() 方法为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数
on() 方法事件处理程序到当前选定的jQuery对象中的元素
delegate() 方法为指定的元素添加一个或多个事件处理程序
live() 方法为被选元素附加一个或多个事件处理程序，并规定当这些事件发生时运行的函数
47、是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？
48、jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle）
49、针对 jQuery性能的优化方法？
https://www.jb51.net/article/87002.htm
（1）总是使用#id去寻找element。
在jQuery中最快的选择器是ID选择器 ($('#someid')). 这是因为它直接映射为JavaScript的getElementById()方法。
（2）在classes前面使用Tags。在jquery中第二快的选择器就是Tag选择器($(`head`))。这是因为它直接映射到js的getElementByTagName()方法。
（3）缓存jquery对象
（4）更好的利用链
（5）使用子查询
（6）限制直接对DOM操作
（7）事件委托（冒泡事件）
除非特别说明，每一个JavaScript事件（如click, mouseover 等）在DOM结构树上都会冒泡到它的父元素上。如果我们想让很多elements(nodes)调用同一个function这是非常有用的。取而代之的是 你可以只对它们的父级绑定一次，而且可以计算出是哪一个节点触发了事件，而不是绑定一个事件监听器到很多节点上这种效率低下的方式。
（8）消除查询浪费
虽然jQuery对没有找到任何匹配的elements处理的很好，但是它还是需要花费时间去查找的。如果你的站点有一个全局的JavaScript，你可能会把每个jQuery function都放在 $(document).ready(function(){ // all my glorious code })里。 不要这样做。只去放一些页面上适合用到的function。这样做最有效的方式是你的模板可以完全控制任何时候或者地方执行JavaScript以内联脚 本的方式初始化function。例如，在你的“article”页面模板里，你可能在body标签关闭之前包含以下代码
<script type="text/javascript>mylib.article.init();</script></body& gt;如果你的页面模板包含多种有可能在页面或者不在页面上的模块，或者为了可视化效果你需要它们稍后再初如化，你应该在这些模块之后立即放置初如化函数。
（9）遵从$(windows).load
有 一种诱惑会使jQuery开发者hook所有事情到 $(document).ready 这个虚伪的事件里。毕竟在大多数例子里都可以看到这样使用。虽然$(document).ready 非常有用，它在页面呈现时发生，虽然其它对象还在下载中。如果你发现你的页面在下载中停顿，就有可能是$(document).ready 引起的。你可以通过把jQuery functions帮定到$(window).load事件来减少下面下载时的CPU使用率，它是在所有HTML（包括iframe内容）都下载完以后才 去调用所有对象的。

50、Jquery与jQuery UI 有啥区别？
 *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。
 *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
  提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等
53、jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：
	$.fn.stringifyArray = function(array) {
	    return JSON.stringify(array)
	}
	$.fn.parseArray = function(array) {
	    return JSON.parse(array)
	}
	然后调用：
	$("").stringifyArray(array)
54、jQuery和Zepto的区别？各自的使用场景？
一、同
zepto最初是为了移动端开发的库，是jquery的轻量级替代品，因为它的API和jquery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，zepto所提供的工具足以满足开发程序的需要。大多数在jquery中常用的api和zepto都有，zepto中还有一些jquery中没有的。另外，因为zepto的兼容，所以用起来及其容易。
二、不同
（1）针对移动端程序，zepto有一些基本的触摸事件可以用来做触摸屏交互，zepto是不支持IE浏览器的。
（2）Dom操作的区别：添加id时jquery不会生效而zepto会生效
（3）事件触发的区别：使用jquery时load事件的处理函数不会执行；使用zepto时load事件的处理函数会执行
（4）事件委托的区别
var $doc = $(document);
$doc.on('click', '.a', function () {
    alert('a事件');
    $(this).removeClass('a').addClass('b');
});
$doc.on('click', '.b', function () {
    alert('b事件');
});
在Zepto中，当a被点击后，依次弹出了内容为”a事件“和”b事件“，说明虽然事件委托在.a上可是却也触发了.b上的委托。但是在 jQuery 中只会触发.a上面的委托弹出”a事件“。Zepto中，document上所有的click委托事件都依次放入到一个队列中，点击的时候先看当前元素是不是.a，符合则执行，然后查看是不是.b，符合则执行。而在jQuery中，document上委托了2个click事件，点击后通过选择符进行匹配，执行相应元素的委托事件。
(5)width()和height()的区别：Zepto由盒模型(box-sizing)决定，用.width()返回赋值的width，用.css('width')返回加border等的结果；jQuery会忽略盒模型，始终返回内容区域的宽/高(不包含padding、border)。
(6)offset()的区别：Zepto返回{top,left,width,height}；jQuery返回{width,height}。
(7)Zepto无法获取隐藏元素宽高，jQuery 可以。
(8)Zepto中没有为原型定义extend方法而jQuery有。
(9)Zepto 的each 方法只能遍历 数组，不能遍历JSON对象。
(10)Zepto在操作dom的selected和checked属性时尽量使用prop方法，在读取属性值的情况下优先于attr。Zepto获取select元素的选中option不能用类似jQuery的方法$('option[selected]'),因为selected属性不是css的标准属性。应该使用$('option').not(function(){ return !this.selected })。

55、针对 jQuery 的优化方法？
 *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。
 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。
  比如：var str=$("a").attr("href");
 *for (var i = size; i < arr.length; i++) {}
  for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
  for (var i = size, length = arr.length; i < length; i++) {}
55、Zepto的点透问题如何解决？
一、“点透”是什么
你可能碰到在列表上创建一个弹出层有一个关闭的按钮，你点了这个按钮关闭弹出层后，这个按钮正下方的内容也会执行点击事件（或打开链接）。这个被定义为这是一个点击“点透”现象。
二、为什么会出现点透
zepto的tap通过监听绑定在docment上的touch事件来完成tap事件的模拟的，及tap事件是冒泡到docment上触发的再点击完成时的tap需要冒泡到docment上才会触发，而在冒泡到docment之前，用户手的接触屏幕和离开屏幕是会触发click事件的，因为click事件还在延迟的300ms之中，当300ms到来的时候，click到的其实不是完成而是隐藏之后的下方的元素，如果正下方的元素绑定的有click事件此时便会触发，如果没有绑定click事件的话就当没click，但是正下方的是input输入框，点击默认聚焦而弹出输入键盘，也就出现了上面的点透现象。
三、点透的解决方法
（1）引入fastclick.js，因为fastclick源码不依赖其他库所以可以在原生的js前加上
 window.addEventListener( "load", function() {
    FastClick.attach( document.body );
 }, false );
（2）用tochend代替tap事件并阻止调touhend的默认行为preventDefault()
 $("#cbFinish").on("touchend", function (event) {
   //很多处理比如隐藏什么的
    event.preventDefault();
 });
(4)延迟一定的时间（300ms+）来处理事件
 $("#cbFinish").on("tap", function (event) {
    setTimeout(function(){
    //很多处理比如隐藏什么的
    },320);
 }); 
56、jQueryUI如何自定义组件?
https://www.cnblogs.com/ambar/archive/2010/11/12/how-to-create-a-jquery-ui-widget.html
57、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？
用cookie或者localStorage来记录应用的状态即可，刷新页面时读取一下这个状态，然后发送相应ajax请求来改变页面即可
 HTML5里引用了新的API，就是history.pushState和history.replaceState，就是通过这个接口做到无刷新改变页面URL的
    虽然ajax可以无刷新改变页面内容，但无法改变页面URL
    其次为了更好的可访问性，内容发生改变后，改变URL的hash。但是hash的方式不能很好的处理浏览器的前进、后退等问题
    有的浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变
    再有，ajax的使用对搜索引擎很不友好，往往蜘蛛爬到的区域是空的
    为了解决传统ajax带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceStat
    可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。
    pushState是将指定的URL添加到浏览器历史里，replaceState是将指定的URL替换当前的URL。
    如何调用
    var state = {    title: title,    url: options.url,    otherkey: othervalue};window.history.pushState(state, document.title, url);
    state对象除了要title和url之外，也可以添加其他的数据，比如：还想将一些发送ajax的配置给保存起来。
    replaceState和pushState是相似的，不需要多做解释。
    如何响应浏览器的前进、后退操作
    window对象上提供了onpopstate事件，上面传递的state对象会成为event的子对象，这样就可以拿到存储的title和URL了。
    window.addEventListener(‘popstate’, function(e){ if (history.state){    var state = e.state; //do something(state.url, state.title); }}, false);
    这样就可以结合ajax和pushState完美的进行无刷新浏览了。

59、如何判断当前脚本运行在浏览器还是node环境中？（阿里）
  this === window ? 'browser' : 'node';
  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中
60、移动端最小触控区域是多大？
移动端最小触控区域44*44px，再小就容易点击不到或者误点，可参考《iOS Human Interface Guidelines》: https://developer.apple.com/library/ios/documentation/userexperience/conceptual/mobilehig/LayoutandAppearance.html

61、jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?
    jquery stop(): 如：$("#div").stop().animate({width:"100px"},100);

62、把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？
html标签只包含head 和body两个标签，解析时，所有标签都会解析进这两个标签里边。body之前的任何位置都会解析进head里边，之后的都会解析进body里边。

63、移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）
https://blog.csdn.net/xjun0812/article/details/64919063

64、Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？

66、那些操作会造成内存泄漏？
 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
67、JQuery一个对象可以同时绑定多个事件，这是如何实现的？
 * 多个事件同一个函数：
 	$("div").on("click mouseover", function(){});
 * 多个事件不同函数
 	$("div").on({
 		click: function(){},
 		mouseover: function(){}
 	});

68、什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?
前端的路由和后端的路由在实现技术上不一样，但是原理都是一样的。在 HTML5 的 history API 出现之前，前端的路由都是通过 hash 来实现的，hash 能兼容低版本的浏览器。如果我们把上面例子中提到的 3 个页面用 hash 来实现的话，它的 URI 规则中需要带上 #。
1 http://10.0.0.1/2 http://10.0.0.1/#/about3 http://10.0.0.1/#/concat
Web 服务并不会解析 hash，也就是说 # 后的内容 Web 服务都会自动忽略，但是 JavaScript 是可以通过 window.location.hash 读取到的，读取到路径加以解析之后就可以响应不同路径的逻辑处理。
history 是 HTML5 才有的新 API，可以用来操作浏览器的 session history。基于 history 来实现的路由可以和最初的例子中提到的路径规则一样。
1 http://10.0.0.1/2 http://10.0.0.1/about3 http://10.0.0.1/concat
三、前端路由的使用场景？
前端路由更多用在单页应用上, 也就是SPA, 因为单页应用, 基本上都是前后端分离的, 后端自然也就不会给前端提供路由。
四、前端路由优缺点
优点：
（1）从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。
（2）在某些场合中，用ajax请求，可以让页面无刷新，页面变了但Url没有变化，用户就不能复制到想要的地址，用前端路由做单页面网页就很好的解决了这个问题
缺点：
使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。

69、用js实现千位分隔符?(来源：前端农民工，提示：正则+replace)
  参考：http://www.tuicool.com/articles/ArQZfui
  function commafy(num) {
      return num && num
          .toString()
          .replace(/(\d)(?=(\d{3})+\.)/g, function($0, $1) {
              return $1 + ",";
          });
  }
  console.log(commafy(1234567.90)); //1,234,567.90
70、检测浏览器版本版本有哪些方式？
  功能检测、userAgent特征检测
  比如：navigator.userAgent
  //"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36
    (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36"

71、我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？

72、使用JS实现获取文件扩展名？
  function getFileExtension(filename) {
    return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2);
  }
  String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。
  对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和-1无符号右移操作符(»>) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。
  String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。
73、Webpack热更新实现原理?
  （1） Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信)
  （2）页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端
  （3） 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash
  （4） 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端
  （5）客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档
  （6）hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。

76、请介绍一下JS之事件节流？

77、什么是JS的函数防抖？
https://www.cnblogs.com/wssdx/p/11557706.html
一、什么是函数防抖
概念：函数防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。
举个栗子，坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10 秒钟之后，才会关闭电梯门开始运行，因此，“函数防抖”的关键在于，在 一个事件 发生 一定时间 之后，才执行 特定动作。二、为什么需要函数防抖
前端开发过程中，有一些事件，常见的例如，onresize，scroll，mousemove ,mousehover 等，会被频繁触发（短时间内多次触发），不做限制的话，有可能一秒之内执行几十次、几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作 DOM 的函数（浏览器操作 DOM 是很耗费性能的），那不仅会浪费计算机资源，还会降低程序运行速度，甚至造成浏览器卡死、崩溃。这种问题显然是致命的。
除此之外，短时间内重复的 ajax 调用不仅会造成数据关系的混乱，还会造成网络拥塞，增加服务器压力，显然这个问题也是需要解决的。
三、函数防抖如何解决上述问题
根据上面对问题的分析，细细思索，可以想到如下解决方案。
函数防抖的要点，是需要一个 setTimeout 来辅助实现，延迟运行需要执行的代码。如果方法多次触发，则把上次记录的延迟执行代码用 clearTimeout 清掉，重新开始计时。若计时期间事件没有被重新触发，等延迟时间计时完毕，则执行目标代码。
四、函数防抖的代码实现
根据以上分析，我们对 “函数防抖” 来进行简单的代码实现，如下：
function debounce(fn,wait){
    var timer = null;
    return function(){
        if(timer !== null){
            clearTimeout(timer);
        }
        timer = setTimeout(fn,wait);
    }
}
    function handle(){
    console.log(Math.random());
}
window.addEventListener("resize",debounce(handle,1000));
以上代码本人亲测有效，小伙伴们可放心食用（注意，函数触发方式为 “resize”，改变窗口大小，观察浏览器控制台的变化）。
五、函数节流的使用场景
函数防抖一般用在什么情况之下呢？一般用在，连续的事件只需触发一次回调的场合。具体有：
(1)搜索框搜索输入。只需用户最后一次输入完，再发送请求；
(2)用户名、手机号、邮箱输入验证；
(3)浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染。
目前遇到过的用处就是这些，理解了原理与实现思路，小伙伴可以把它运用在任何需要的场合，提高代码质量。
总结
函数防抖其实是分为 “立即执行版” 和 “非立即执行版” 的，根据字面意思就可以发现他们的差别，所谓立即执行版就是 触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 而 “非立即执行版” 指的是 触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。。
在开发过程中，我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版本的防抖函数，以下为小伙伴们做了简单的实现：
/**
* @desc 函数防抖---“立即执行版本” 和 “非立即执行版本” 的组合版本
* @param func 需要执行的函数
* @param wait 延迟执行时间（毫秒）
* @param immediate---true 表立即执行，false 表非立即执行
**/
function debounce(func,wait,immediate) {
let timer;
return function () {
let context = this;
let args = arguments;
if (timer) clearTimeout(timer);
if (immediate) {
var callNow = !timer;
timer = setTimeout(() => {
timer = null;
}, wait)
if (callNow) func.apply(context, args)
} else {
timer = setTimeout(function(){
func.apply(context, args)
}, wait);
}
}
}
function handle(){
console.log(Math.random());
}
// window.addEventListener("mousemove",debounce(handle,1000,true)); // 调用立即执行版本
window.addEventListener("mousemove",debounce(handle,1000,false)); // 调用非立即执行版本

78、ES6是如何实现编译成ES5的？

79、css-loader的原理？

80、对async 和 await的认识
https://segmentfault.com/a/1190000019006291?utm_source=tag-newest

81、es6继承和es5继承的区别
https://www.cnblogs.com/annika/p/9073572.html



 
























